<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Korean Grammar Practice</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          animation: {
            'gradient': 'gradient 15s ease infinite',
            'gradient-text': 'gradient-text 3s ease infinite',
            'blob': 'blob 7s infinite',
            'float': 'float 6s ease-in-out infinite',
            'bounce-subtle': 'bounce-subtle 2s ease-in-out infinite',
            'twinkle': 'twinkle 1.5s ease-in-out infinite',
          }
        }
      }
    }
  </script>
  <style>
    @keyframes gradient {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    
    @keyframes gradient-text {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    
    @keyframes blob {
      0%, 100% { transform: translate(0, 0) scale(1); }
      25% { transform: translate(20px, -50px) scale(1.1); }
      50% { transform: translate(-20px, 20px) scale(0.9); }
      75% { transform: translate(50px, 50px) scale(1.05); }
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      25% { transform: translateY(-20px) rotate(5deg); }
      50% { transform: translateY(-40px) rotate(-5deg); }
      75% { transform: translateY(-20px) rotate(3deg); }
    }
    
    @keyframes bounce-subtle {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
    }
    
    @keyframes twinkle {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(0.95); }
    }
    
    /* Vocabulary Flashcard 3D Flip Animation */
    .transform-style-preserve-3d {
      transform-style: preserve-3d;
    }
    
    .rotate-y-180 {
      transform: rotateY(180deg);
    }
    
    .backface-hidden {
      backface-visibility: hidden;
    }
    
    .gradient-bg {
      background: linear-gradient(-45deg, #a855f7, #e879f9, #06b6d4, #a855f7);
      background-size: 400% 400%;
      animation: gradient 15s ease infinite;
    }

    /* New Design System - Animated Background */
    .page-background {
      position: fixed;
      inset: 0;
      background: linear-gradient(to bottom right, #a78bfa, #f0abfc, #67e8f9);
      background-size: 200% 200%;
      animation: gradient 15s ease infinite;
    }

    .gradient-mesh {
      position: absolute;
      inset: 0;
      opacity: 0.3;
    }

    .gradient-mesh .blob-1 {
      position: absolute;
      top: 0;
      left: 0;
      width: 24rem;
      height: 24rem;
      background: #a855f7;
      border-radius: 50%;
      mix-blend-mode: multiply;
      filter: blur(3rem);
      animation: blob 20s ease-in-out infinite;
    }

    .gradient-mesh .blob-2 {
      position: absolute;
      top: 0;
      right: 0;
      width: 24rem;
      height: 24rem;
      background: #eab308;
      border-radius: 50%;
      mix-blend-mode: multiply;
      filter: blur(3rem);
      animation: blob 20s ease-in-out infinite;
      animation-delay: 2s;
    }

    .gradient-mesh .blob-3 {
      position: absolute;
      bottom: 0;
      left: 50%;
      width: 24rem;
      height: 24rem;
      background: #ec4899;
      border-radius: 50%;
      mix-blend-mode: multiply;
      filter: blur(3rem);
      animation: blob 20s ease-in-out infinite;
      animation-delay: 4s;
    }

    /* Floating Korean Characters */
    .floating-char {
      position: absolute;
      color: rgba(255, 255, 255, 0.1);
      font-weight: bold;
      pointer-events: none;
      animation: float 20s ease-in-out infinite;
    }

    /* Glassmorphism Container */
    .content-container {
      position: relative;
      z-index: 10;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 3rem 1.5rem;
    }

    .glass-card {
      width: 100%;
      max-width: 56rem;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(40px);
      border-radius: 1.5rem;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      padding: 2rem;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    @media (min-width: 768px) {
      .glass-card {
        padding: 3rem;
      }
    }

    /* Gradient Text */
    .gradient-text {
      background: linear-gradient(to right, #a855f7, #ec4899, #3b82f6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      background-size: 200% 200%;
      animation: gradient-text 3s ease infinite;
      font-weight: 800;
    }

    /* Button Styles */
    .btn-primary {
      background: linear-gradient(to right, #8b5cf6, #ec4899);
      color: white;
      padding: 0.75rem 2rem;
      border-radius: 0.75rem;
      font-weight: 600;
      box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
      transition: all 0.3s;
      border: none;
    }

    .btn-primary:hover {
      background: linear-gradient(to right, #7c3aed, #db2777);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(139, 92, 246, 0.6);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.9);
      color: #8b5cf6;
      border: 2px solid #a78bfa;
      padding: 0.75rem 2rem;
      border-radius: 0.75rem;
      font-weight: 600;
      transition: all 0.3s;
    }

    .btn-secondary:hover {
      background: rgba(167, 139, 250, 0.1);
      transform: translateY(-2px);
    }

    /* Progress Bar */
    .progress-bar-container {
      width: 100%;
      height: 8px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 9999px;
      overflow: hidden;
      margin-bottom: 2rem;
    }

    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(to right, #a78bfa, #ec4899);
      transition: width 0.5s ease;
      border-radius: 9999px;
    }

    /* Loading Spinner */
    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(167, 139, 250, 0.2);
      border-top-color: #a78bfa;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* Animations */
    @keyframes gradient-text {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    @keyframes blob {
      0%, 100% { transform: translate(0, 0) scale(1); }
      25% { transform: translate(20px, -50px) scale(1.1); }
      50% { transform: translate(-20px, 20px) scale(0.9); }
      75% { transform: translate(50px, 50px) scale(1.05); }
    }

    @keyframes float {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      25% { transform: translateY(-20px) rotate(5deg); }
      50% { transform: translateY(-40px) rotate(-5deg); }
      75% { transform: translateY(-20px) rotate(3deg); }
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @keyframes scale-in {
      from {
        transform: scale(0);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* Epic Boss Battle Animations */
    .boss-sprite {
      transition: all 0.3s ease;
      animation: boss-idle 3s ease-in-out infinite;
    }

    .boss-sprite.attacking {
      animation: boss-attack 0.5s ease;
    }

    .boss-sprite.confident {
      filter: hue-rotate(0deg);
    }

    .boss-sprite.worried {
      filter: hue-rotate(30deg);
      animation: boss-worried 1s ease-in-out infinite;
    }

    .boss-sprite.angry {
      filter: hue-rotate(345deg) saturate(1.5);
      animation: boss-rage 0.5s ease-in-out infinite;
    }

    @keyframes boss-idle {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    @keyframes boss-attack {
      0% { transform: scale(1) translateY(0); }
      50% { transform: scale(1.2) translateY(-20px); }
      100% { transform: scale(1) translateY(0); }
    }

    @keyframes boss-worried {
      0%, 100% { transform: rotate(-2deg); }
      50% { transform: rotate(2deg); }
    }

    @keyframes boss-rage {
      0%, 100% { transform: rotate(-3deg) scale(1.1); }
      50% { transform: rotate(3deg) scale(1.15); }
    }

    /* Attack effects */
    @keyframes attack-beam {
      0% {
        transform: scaleX(0);
        opacity: 1;
      }
      50% {
        opacity: 1;
      }
      100% {
        transform: scaleX(1);
        opacity: 0;
      }
    }

    .attack-effect {
      position: absolute;
      width: 100%;
      height: 20px;
      background: linear-gradient(90deg, transparent, #ffdd00, transparent);
      animation: attack-beam 0.5s ease;
    }

    /* Damage numbers */
    @keyframes damage-float {
      0% {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
      100% {
        transform: translateY(-100px) scale(1.5);
        opacity: 0;
      }
    }

    .damage-number {
      position: absolute;
      font-size: 3rem;
      font-weight: 900;
      color: #ffdd00;
      text-shadow: 0 0 10px rgba(255, 221, 0, 0.8);
      animation: damage-float 1.5s ease-out;
      pointer-events: none;
      z-index: 100;
    }

    /* Combo display */
    .combo-display {
      animation: combo-pulse 0.3s ease;
    }

    @keyframes combo-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    /* Screen shake on big hits */
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }

    .screen-shake {
      animation: shake 0.5s ease;
    }

    /* Health bar animations */
    .health-bar-fill {
      transition: width 0.5s ease, background 0.3s ease;
    }

    /* Victory/Defeat animations */
    @keyframes victory-entrance {
      0% {
        transform: scale(0) rotate(-180deg);
        opacity: 0;
      }
      50% {
        transform: scale(1.2) rotate(10deg);
      }
      100% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
    }

    .victory-screen {
      animation: victory-entrance 1s ease;
    }

    /* Boss dialogue animation */
    @keyframes dialogue-pop {
      0% {
        transform: scale(0) translateY(20px);
        opacity: 0;
      }
      50% {
        transform: scale(1.1) translateY(-5px);
      }
      100% {
        transform: scale(1) translateY(0);
        opacity: 1;
      }
    }

    .boss-dialogue {
      animation: dialogue-pop 0.5s ease;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect } = React;
    
    // Lucide icons as components
    const CheckCircle = () => (
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
        <polyline points="22 4 12 14.01 9 11.01"></polyline>
      </svg>
    );
    
    const XCircle = () => (
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="15" y1="9" x2="9" y2="15"></line>
        <line x1="9" y1="9" x2="15" y2="15"></line>
      </svg>
    );
    
    const ArrowRight = () => (
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="5" y1="12" x2="19" y2="12"></line>
        <polyline points="12 5 19 12 12 19"></polyline>
      </svg>
    );
    
    const ArrowLeft = () => (
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="19" y1="12" x2="5" y2="12"></line>
        <polyline points="12 19 5 12 12 5"></polyline>
      </svg>
    );
    
    const Sparkles = () => (
      <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"></path>
        <path d="M5 3v4"></path>
        <path d="M19 17v4"></path>
        <path d="M3 5h4"></path>
        <path d="M17 19h4"></path>
      </svg>
    );
    
    const Star = () => (
      <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
      </svg>
    );

    const Brain = () => (
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M12 5a3 3 0 1 0-5.997.125 4 4 0 0 0-2.526 5.77 4 4 0 0 0 .556 6.588A4 4 0 1 0 12 18Z"></path>
        <path d="M12 5a3 3 0 1 1 5.997.125 4 4 0 0 1 2.526 5.77 4 4 0 0 1-.556 6.588A4 4 0 1 1 12 18Z"></path>
        <path d="M15 13a4.5 4.5 0 0 1-3-4 4.5 4.5 0 0 1-3 4"></path>
        <path d="M17.599 6.5a3 3 0 0 0 .399-1.375"></path>
        <path d="M6.003 5.125A3 3 0 0 0 6.401 6.5"></path>
        <path d="M3.477 10.896a4 4 0 0 1 .585-.396"></path>
        <path d="M19.938 10.5a4 4 0 0 1 .585.396"></path>
        <path d="M6 18a4 4 0 0 1-1.967-.516"></path>
        <path d="M19.967 17.484A4 4 0 0 1 18 18"></path>
      </svg>
    );

    const Zap = () => (
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
      </svg>
    );

    const Shuffle = () => (
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M2 18h1.4c1.3 0 2.5-.6 3.3-1.7l6.1-8.6c.8-1.1 2-1.7 3.3-1.7H22"></path>
        <path d="m18 2 4 4-4 4"></path>
        <path d="m18 14 4 4-4 4"></path>
        <path d="M22 6h-1.4c-1.3 0-2.5.6-3.3 1.7l-6.1 8.6c-.8 1.1-2 1.7-3.3 1.7H2"></path>
      </svg>
    );

    const BookOpen = () => (
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
        <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
      </svg>
    );

    // Must Know Korean Phrases data
    const mustKnowPhrases = {
      category1: {
        title: "MUST-KNOW KOREAN PHRASES #1",
        phrases: [
          { english: "All set?", korean: "다 준비됐어?" },
          { english: "Anything else?", korean: "다른 건 없어?" },
          { english: "Are you sure?", korean: "확실해?" },
          { english: "Cool", korean: "좋네. 좋아" },
          { english: "Correct", korean: "맞아" },
          { english: "Cut it out", korean: "그만 좀 해. 작작해." },
          { english: "Depends.", korean: "그때그때 달라." },
          { english: "Don't get me wrong.", korean: "오해하지 마." },
          { english: "Don't worry about it.", korean: "걱정하지 마." },
          { english: "Enjoy.", korean: "맛있게 먹어." },
          { english: "Fair enough.", korean: "그래 인정." },
          { english: "Glad to hear that.", korean: "다행이야" },
          { english: "Good for you.", korean: "잘됐네. 축하해." },
          { english: "Hang on a second.", korean: "잠깐만. 잠시만" }
        ]
      },
      category2: {
        title: "MUST-KNOW KOREAN PHRASES #2",
        phrases: [
          { english: "agreed", korean: "동의해" },
          { english: "are you kidding me?", korean: "장난해?" },
          { english: "as you wish", korean: "너 좋을대로 해" },
          { english: "beats me", korean: "나도 몰라" },
          { english: "Do me a favor", korean: "부탁 하나만 할게" },
          { english: "Go ahead", korean: "먼저 해" },
          { english: "Got it", korean: "알겠어" },
          { english: "How come?", korean: "어째서? 왜?" },
          { english: "How did it go?", korean: "어떻게 됐어?" },
          { english: "I didn't mean it", korean: "일부러 그런거 아니야" },
          { english: "I don't get it", korean: "이해가 안돼" },
          { english: "I gotta go", korean: "나 가야겠다" },
          { english: "I knew it", korean: "그럴줄 알았어" },
          { english: "I take it back", korean: "그 말은 취소할게" }
        ]
      },
      category3: {
        title: "MUST-KNOW KOREAN PHRASES #3",
        phrases: [
          { english: "take care", korean: "잘 가" },
          { english: "text me", korean: "문자 해" },
          { english: "that looks good on you", korean: "그거 너한테 잘 어울려" },
          { english: "that was so close!", korean: "너무 아깝다!" },
          { english: "that's what I'm saying", korean: "내 말이 그거야" },
          { english: "time flies", korean: "시간 진짜 빠르다" },
          { english: "we'll see", korean: "상황 좀 보자" },
          { english: "what about it?", korean: "그게 뭐?" },
          { english: "what can I say?", korean: "어쩌겠어?" },
          { english: "what does that mean?", korean: "그게 무슨 뜻이야?" },
          { english: "what happened?", korean: "어떻게 된거야? 무슨일이야?" },
          { english: "what's the occasion?", korean: "오늘 무슨 날이야?" },
          { english: "whatever", korean: "그러든지" },
          { english: "you got me", korean: "들켰다." },
          { english: "you know what?", korean: "그거 알아?" }
        ]
      }
    };

    const KoreanGrammarApp = () => {
      const [grammarPatterns, setGrammarPatterns] = useState(null);
      const [screen, setScreen] = useState('tier-selection');

      const [selectedTier, setSelectedTier] = useState(null);
      const [selectedPattern, setSelectedPattern] = useState(null);
      const [difficulty, setDifficulty] = useState(null);
      const [inputMode, setInputMode] = useState(null);
      const [currentSentenceSet, setCurrentSentenceSet] = useState(null);
      const [challengeMode, setChallengeMode] = useState(null);
      const [timeLimit, setTimeLimit] = useState(null);
      const [score, setScore] = useState(0);
      const [streak, setStreak] = useState(0);
      const [currentTense, setCurrentTense] = useState('past');
      const [shuffledParts, setShuffledParts] = useState([]);
      const [selectedParts, setSelectedParts] = useState([]);
      const [typedAnswer, setTypedAnswer] = useState('');
      const [showFeedback, setShowFeedback] = useState(false);
      const [isCorrect, setIsCorrect] = useState(false);
      const [questionsAnswered, setQuestionsAnswered] = useState(0);
      const [tensesCompleted, setTensesCompleted] = useState([]);
      
      // Phrases section states
      const [expandedCategory, setExpandedCategory] = useState(null);
      const [searchTerm, setSearchTerm] = useState("");
      
      // Quiz and Flashcard states
      const [phrasesMode, setPhrasesMode] = useState('browse'); // 'browse', 'quiz', 'flashcards'
      const [currentQuestion, setCurrentQuestion] = useState(0);
      const [quizQuestions, setQuizQuestions] = useState([]);
      const [selectedAnswer, setSelectedAnswer] = useState(null);
      const [showAnswer, setShowAnswer] = useState(false);
      const [quizScore, setQuizScore] = useState(0);
      const [quizResults, setQuizResults] = useState([]);
      const [currentFlashcard, setCurrentFlashcard] = useState(0);
      const [flashcardSide, setFlashcardSide] = useState('front'); // 'front' or 'back'
      const [learnedPhrases, setLearnedPhrases] = useState(() => {
        const saved = localStorage.getItem('korean-phrases-learned');
        return saved ? JSON.parse(saved) : {};
      });
      const [flashcardPhrases, setFlashcardPhrases] = useState([]);
      
      // Vocabulary Flashcard states
      const [vocabularyCards, setVocabularyCards] = useState([]);
      const [currentVocabularyCard, setCurrentVocabularyCard] = useState(0);
      const [isVocabularyFlipped, setIsVocabularyFlipped] = useState(false);
      const [isVocabularyMuted, setIsVocabularyMuted] = useState(true);
      
      // Heat Map and Boss Battle states
      const [heatMapData, setHeatMapData] = useState(() => {
        const saved = localStorage.getItem('korean-grammar-heatmap');
        return saved ? JSON.parse(saved) : {};
      });
      const [bossBattleMode, setBossBattleMode] = useState(false);
      const [bossHealth, setBossHealth] = useState(100);
      const [currentBoss, setCurrentBoss] = useState(null);
      const [bossBattlesCompleted, setBossBattlesCompleted] = useState(0);
      
      // Epic Boss Battle System States
      const [playerHealth, setPlayerHealth] = useState(5); // 5 hearts
      const [battleCombo, setBattleCombo] = useState(0);
      const [battleDamage, setBattleDamage] = useState(10); // base damage
      const [bossPhase, setBossPhase] = useState(1); // 1, 2, 3
      const [bossAttacking, setBossAttacking] = useState(false);
      const [showAttackEffect, setShowAttackEffect] = useState(false);
      const [showDamageNumbers, setShowDamageNumbers] = useState(false);
      const [lastDamage, setLastDamage] = useState(0);
      const [activePowerUps, setActivePowerUps] = useState([]);
      const [battleStartTime, setBattleStartTime] = useState(null);
      const [battleStats, setBattleStats] = useState({
        questionsAnswered: 0,
        correctAnswers: 0,
        maxCombo: 0,
        timeElapsed: 0
      });
      
      // Test System States
      const [testMode, setTestMode] = useState(null); // 'beginner', 'intermediate', 'advanced'
      const [testQuestions, setTestQuestions] = useState([]);
      const [currentTestQuestion, setCurrentTestQuestion] = useState(0);
      const [testAnswers, setTestAnswers] = useState([]);
      const [testStartTime, setTestStartTime] = useState(null);
      const [testTimeLimit, setTestTimeLimit] = useState(null);
      const [testTimeRemaining, setTestTimeRemaining] = useState(null);
      const [testScore, setTestScore] = useState(0);
      const [testStreak, setTestStreak] = useState(0);
      const [testResults, setTestResults] = useState(null);
      const [testInProgress, setTestInProgress] = useState(false);
      const [selectedTestParts, setSelectedTestParts] = useState([]);

      const distractorWords = {
        beginner: ['어제', '내일', '오늘', '지금', '학교에', '집에', '친구랑', '혼자', '공부하러', '가요', '저는', '이것은'],
        intermediate: ['어제', '내일', '오늘', '지금', '매일', '학교에', '집에', '회사에', '친구랑', '혼자', '공부하러', '일하러', '가요', '간다', '그래서', '하지만'],
        advanced: ['어제', '내일', '오늘', '지금', '학교에', '집에', '회사에', '강남에', '친구랑', '부모님이랑', '혼자서', '공부하러', '일하러', '가요', '간다', '가셨어요', '그래서', '하지만', '왜냐하면']
      };

      useEffect(() => {
        console.log('Fetching sentences.json...');
        fetch('sentences.json?v=' + Date.now())
          .then(response => {
            console.log('Response status:', response.status);
            return response.json();
          })
          .then(data => {
            console.log('Data loaded successfully:', data);
            setGrammarPatterns(data);
          })
          .catch(error => {
            console.error('Error loading sentences:', error);
          });
      }, []);

      // Save heat map data to localStorage whenever it changes
      useEffect(() => {
        localStorage.setItem('korean-grammar-heatmap', JSON.stringify(heatMapData));
      }, [heatMapData]);

      // Save learned phrases to localStorage whenever it changes
      useEffect(() => {
        localStorage.setItem('korean-phrases-learned', JSON.stringify(learnedPhrases));
      }, [learnedPhrases]);

      // Load vocabulary cards from JSON file
      useEffect(() => {
        const loadVocabulary = async () => {
          try {
            const response = await fetch('vocabulary.json');
            if (!response.ok) {
              throw new Error('Failed to fetch vocabulary.json');
            }
            const data = await response.json();
            console.log('Loaded vocabulary:', data);
            setVocabularyCards(data.vocabularyCards || []);
          } catch (error) {
            console.error('Error loading vocabulary:', error);
            // Fallback vocabulary cards if file doesn't exist
            setVocabularyCards([
              {
                id: 1,
                word: "늦다",
                romanization: "neutda",
                frontTitle: "늦다",
                meaning: "to be late / to do something late",
                description: [
                  "Used when talking about time – when someone or something is delayed or not on time.",
                  "It's about being late, not about the speed of something."
                ],
                examples: [
                  { korean: "수업에 늦었어요.", english: "I was late for class." },
                  { korean: "너무 늦게 잤어요.", english: "I went to bed too late." },
                  { korean: "지금 가면 늦을 거예요.", english: "If you go now, you'll be late." }
                ]
              }
            ]);
          }
        };
        loadVocabulary();
      }, []);

      // Quiz Functions
      const generateQuizQuestions = (category = null) => {
        let allPhrases = [];
        
        if (category) {
          allPhrases = mustKnowPhrases[category].phrases.map(phrase => ({
            ...phrase,
            category: category
          }));
        } else {
          // Get all phrases from all categories
          Object.entries(mustKnowPhrases).forEach(([catKey, category]) => {
            category.phrases.forEach(phrase => {
              allPhrases.push({
                ...phrase,
                category: catKey
              });
            });
          });
        }

        const questions = [];
        const usedPhrases = new Set();

        // Generate 10 questions
        for (let i = 0; i < Math.min(10, allPhrases.length); i++) {
          let phrase;
          do {
            phrase = allPhrases[Math.floor(Math.random() * allPhrases.length)];
          } while (usedPhrases.has(phrase.english + phrase.korean));
          
          usedPhrases.add(phrase.english + phrase.korean);

          // Randomly choose English->Korean or Korean->English
          const isEnglishToKorean = Math.random() < 0.5;
          
          if (isEnglishToKorean) {
            // English to Korean question
            const correctAnswer = phrase.korean;
            const wrongAnswers = allPhrases
              .filter(p => p.korean !== correctAnswer)
              .map(p => p.korean)
              .sort(() => Math.random() - 0.5)
              .slice(0, 3);
            
            const allAnswers = [correctAnswer, ...wrongAnswers].sort(() => Math.random() - 0.5);
            
            questions.push({
              question: phrase.english,
              correctAnswer: correctAnswer,
              allAnswers: allAnswers,
              type: 'english-to-korean',
              category: phrase.category
            });
          } else {
            // Korean to English question
            const correctAnswer = phrase.english;
            const wrongAnswers = allPhrases
              .filter(p => p.english !== correctAnswer)
              .map(p => p.english)
              .sort(() => Math.random() - 0.5)
              .slice(0, 3);
            
            const allAnswers = [correctAnswer, ...wrongAnswers].sort(() => Math.random() - 0.5);
            
            questions.push({
              question: phrase.korean,
              correctAnswer: correctAnswer,
              allAnswers: allAnswers,
              type: 'korean-to-english',
              category: phrase.category
            });
          }
        }

        return questions;
      };

      const startQuiz = (category = null) => {
        const questions = generateQuizQuestions(category);
        setQuizQuestions(questions);
        setCurrentQuestion(0);
        setSelectedAnswer(null);
        setShowAnswer(false);
        setQuizScore(0);
        setQuizResults([]);
        setPhrasesMode('quiz');
      };

      const startFlashcards = (category = null) => {
        let allPhrases = [];
        
        if (category) {
          allPhrases = mustKnowPhrases[category].phrases.map(phrase => ({
            ...phrase,
            category: category
          }));
        } else {
          Object.entries(mustKnowPhrases).forEach(([catKey, category]) => {
            category.phrases.forEach(phrase => {
              allPhrases.push({
                ...phrase,
                category: catKey
              });
            });
          });
        }

        // Prioritize phrases that haven't been learned yet
        const unlearnedPhrases = allPhrases.filter(phrase => 
          !learnedPhrases[phrase.english + phrase.korean]
        );
        
        // If all phrases are learned, show all phrases
        const phrasesToShow = unlearnedPhrases.length > 0 ? unlearnedPhrases : allPhrases;
        
        setFlashcardPhrases(phrasesToShow);
        setCurrentFlashcard(0);
        setFlashcardSide('front');
        setPhrasesMode('flashcards');
      };

      const handleQuizAnswer = (answer) => {
        if (showAnswer) return;
        
        setSelectedAnswer(answer);
        setShowAnswer(true);
        
        const isCorrect = answer === quizQuestions[currentQuestion].correctAnswer;
        const newScore = isCorrect ? quizScore + 1 : quizScore;
        setQuizScore(newScore);
        
        setQuizResults([...quizResults, {
          question: quizQuestions[currentQuestion].question,
          correctAnswer: quizQuestions[currentQuestion].correctAnswer,
          selectedAnswer: answer,
          isCorrect: isCorrect,
          type: quizQuestions[currentQuestion].type
        }]);
      };

      const nextQuizQuestion = () => {
        if (currentQuestion < quizQuestions.length - 1) {
          setCurrentQuestion(currentQuestion + 1);
          setSelectedAnswer(null);
          setShowAnswer(false);
        }
      };

      const finishQuiz = () => {
        setPhrasesMode('browse');
        setCurrentQuestion(0);
        setQuizQuestions([]);
        setSelectedAnswer(null);
        setShowAnswer(false);
      };

      const markPhraseAsLearned = (phrase, learned = true) => {
        const key = phrase.english + phrase.korean;
        setLearnedPhrases(prev => ({
          ...prev,
          [key]: learned
        }));
      };

      const nextFlashcard = () => {
        if (currentFlashcard < flashcardPhrases.length - 1) {
          setCurrentFlashcard(currentFlashcard + 1);
          setFlashcardSide('front');
        } else {
          setPhrasesMode('browse');
        }
      };

      const previousFlashcard = () => {
        if (currentFlashcard > 0) {
          setCurrentFlashcard(currentFlashcard - 1);
          setFlashcardSide('front');
        }
      };

      const flipFlashcard = () => {
        setFlashcardSide(flashcardSide === 'front' ? 'back' : 'front');
      };

      // Vocabulary Flashcard Functions
      const handleVocabularyFlip = () => {
        setIsVocabularyFlipped(!isVocabularyFlipped);
      };

      const handleVocabularyNext = () => {
        if (currentVocabularyCard < vocabularyCards.length - 1) {
          setCurrentVocabularyCard(currentVocabularyCard + 1);
          setIsVocabularyFlipped(false);
        }
      };

      const handleVocabularyPrev = () => {
        if (currentVocabularyCard > 0) {
          setCurrentVocabularyCard(currentVocabularyCard - 1);
          setIsVocabularyFlipped(false);
        }
      };

      const toggleVocabularyMute = () => {
        setIsVocabularyMuted(!isVocabularyMuted);
      };

      // Heat Map Functions
      const updateHeatMap = (patternId, tier, correct) => {
        const key = `${tier}-${patternId}`;
        setHeatMapData(prev => {
          const newData = { ...prev };
          if (!newData[key]) {
            newData[key] = { practiced: 0, correct: 0, incorrect: 0 };
          }
          newData[key].practiced++;
          if (correct) {
            newData[key].correct++;
          } else {
            newData[key].incorrect++;
          }
          return newData;
        });
      };

      const resetHeatMap = () => {
        setHeatMapData({});
        localStorage.removeItem('korean-grammar-heatmap');
      };

      const getHeatMapStats = () => {
        const stats = {};
        Object.keys(heatMapData).forEach(key => {
          const data = heatMapData[key];
          const accuracy = data.practiced > 0 ? (data.correct / data.practiced * 100).toFixed(1) : 0;
          stats[key] = {
            practiced: data.practiced,
            accuracy: parseFloat(accuracy),
            needsWork: data.incorrect > data.correct
          };
        });
        return stats;
      };

      // Random Mode Functions
      const startRandomMode = () => {
        console.log('Starting Random Mode...');
        console.log('grammarPatterns:', grammarPatterns);
        
        if (!grammarPatterns) {
          console.log('No grammar patterns available');
          return;
        }
        
        // Collect all patterns from all tiers
        const allPatterns = [];
        Object.keys(grammarPatterns).forEach(tier => {
          if (grammarPatterns[tier] && Array.isArray(grammarPatterns[tier])) {
            grammarPatterns[tier].forEach(pattern => {
              allPatterns.push({
                ...pattern,
                tier: tier
              });
            });
          }
        });
        
        console.log('All patterns:', allPatterns.length);
        
        if (allPatterns.length === 0) {
          console.log('No patterns found');
          return;
        }
        
        // Pick a random pattern
        const randomPattern = allPatterns[Math.floor(Math.random() * allPatterns.length)];
        console.log('Random pattern selected:', randomPattern);
        
        // Get all sentences from this pattern
        const allSentences = [];
        Object.keys(randomPattern.sentences).forEach(difficulty => {
          if (randomPattern.sentences[difficulty]) {
            if (randomPattern.tenseVariations) {
              // For patterns with tense variations, add each tense
              randomPattern.sentences[difficulty].forEach(sentenceSet => {
                Object.keys(sentenceSet).forEach(tense => {
                  if (sentenceSet[tense] && sentenceSet[tense].parts) {
                    allSentences.push({
                      ...sentenceSet[tense],
                      difficulty: difficulty,
                      tense: tense,
                      patternId: randomPattern.id,
                      patternName: randomPattern.name,
                      tier: randomPattern.tier
                    });
                  }
                });
              });
            } else {
              // For patterns without tense variations
              randomPattern.sentences[difficulty].forEach(sentence => {
                if (sentence && sentence.parts) {
                  allSentences.push({
                    ...sentence,
                    difficulty: difficulty,
                    patternId: randomPattern.id,
                    patternName: randomPattern.name,
                    tier: randomPattern.tier
                  });
                }
              });
            }
          }
        });
        
        console.log('All sentences:', allSentences.length);
        
        if (allSentences.length === 0) {
          console.log('No valid sentences found');
          return;
        }
        
        // Pick a random sentence
        const randomSentence = allSentences[Math.floor(Math.random() * allSentences.length)];
        console.log('Random sentence selected:', randomSentence);
        
        // Set up the random mode
        setSelectedPattern(randomPattern);
        setDifficulty(randomSentence.difficulty);
        
        // Handle sentence structure properly for Random Mode
        if (randomSentence.tense && randomPattern.tenseVariations) {
          // For tense variations, we need to structure it properly
          const tenseSentenceSet = {};
          tenseSentenceSet[randomSentence.tense] = {
            parts: randomSentence.parts,
            meaning: randomSentence.meaning
          };
          setCurrentSentenceSet(tenseSentenceSet);
          setCurrentTense(randomSentence.tense);
        } else {
          // For direct sentences (no tense variations)
          setCurrentSentenceSet({
            parts: randomSentence.parts,
            meaning: randomSentence.meaning
          });
        }
        
        setScreen('practice');
        
        // Set random input mode (50/50 chance)
        const randomInputMode = Math.random() < 0.5 ? 'tap' : 'typing';
        setInputMode(randomInputMode);
        
        // Reset states
        setShuffledParts([]);
        setSelectedParts([]);
        setTypedAnswer('');
        setShowFeedback(false);
        setIsCorrect(false);
        
        console.log('About to setup question...');
        // Setup question properly - pass the structured sentence
        if (randomSentence.tense && randomPattern.tenseVariations) {
          setupQuestion({
            [randomSentence.tense]: {
              parts: randomSentence.parts,
              meaning: randomSentence.meaning
            }
          }, randomSentence.tense);
        } else {
          setupQuestion({
            parts: randomSentence.parts,
            meaning: randomSentence.meaning
          }, null);
        }
      };

      // Boss Battle Functions
      const startBossBattle = () => {
        if (!grammarPatterns?.combo) return;
        
        const comboPatterns = grammarPatterns.combo;
        const randomBoss = comboPatterns[Math.floor(Math.random() * comboPatterns.length)];
        
        setCurrentBoss({
          name: randomBoss.name,
          description: randomBoss.description,
          pattern: randomBoss,
          difficulty: 'advanced',
          attacksRemaining: 5, // Boss needs 5 correct answers to defeat
          specialAbility: 'Multi-Pattern Master' // Boss special ability
        });
        
        // Initialize Epic Battle System
        setBossHealth(100);
        setPlayerHealth(5);
        setBattleCombo(0);
        setBattleDamage(10);
        setBossPhase(1);
        setBossAttacking(false);
        setShowAttackEffect(false);
        setShowDamageNumbers(false);
        setActivePowerUps([]);
        setBattleStartTime(Date.now());
        setBattleStats({
          questionsAnswered: 0,
          correctAnswers: 0,
          maxCombo: 0,
          timeElapsed: 0
        });
        
        setBossBattleMode(true);
        setScreen('boss-battle');
        
        // Generate a super-challenging combo sentence
        generateBossSentence(randomBoss);
      };

      const generateBossSentence = (bossPattern) => {
        // Create a sentence that combines multiple grammar patterns for maximum difficulty
        const comboSentences = bossPattern.sentences.boss;
        const randomSentence = comboSentences[Math.floor(Math.random() * comboSentences.length)];
        
        // Make boss sentences harder by adding more distractors
        setCurrentSentenceSet(randomSentence);
        setSelectedPattern(bossPattern);
        setDifficulty('advanced');
        
        // Boss battles always use typing mode for maximum challenge
        setInputMode('typing');
        
        // Setup question with more distractors for boss battles
        const correctParts = [...randomSentence.parts];
        const distractors = [
          ...distractorWords.advanced,
          '그러니까', '그런데', '하지만', '그래서', '왜냐하면',
          '아무리', '비록', '만약', '설령', '혹시',
          '정말', '정말로', '진짜', '완전히', '정말로'
        ];
        
        const numDistractors = 8; // More distractors for boss battles
        const selectedDistractors = [];
        const shuffledDistractors = shuffleArray([...distractors]);

        for (let i = 0; i < numDistractors && i < shuffledDistractors.length; i++) {
          if (!correctParts.includes(shuffledDistractors[i])) {
            selectedDistractors.push(shuffledDistractors[i]);
          }
        }

        const allParts = [...correctParts, ...selectedDistractors];
        setShuffledParts(shuffleArray(allParts));
        setSelectedParts([]);
        setTypedAnswer('');
        setShowFeedback(false);
        setIsCorrect(false);
      };

      const bossAttack = () => {
        setCurrentBoss(prev => {
          const newBoss = { ...prev, attacksRemaining: prev.attacksRemaining - 1 };
          if (newBoss.attacksRemaining <= 0) {
            // Boss defeated!
            setBossBattlesCompleted(prev => prev + 1);
            setTimeout(() => {
              setBossBattleMode(false);
              setScreen('tier-selection');
              setCurrentBoss(null);
              setBossHealth(100);
            }, 3000);
          } else {
            // Generate next boss sentence
            setTimeout(() => {
              generateBossSentence(newBoss.pattern);
            }, 1500);
          }
          return newBoss;
        });
      };

      const bossDefend = () => {
        // Boss gets stronger with each wrong answer
        setCurrentBoss(prev => ({ ...prev, attacksRemaining: prev.attacksRemaining + 1 }));
        setScore(prev => Math.max(0, prev - 2));
        
        // Generate new boss sentence after wrong answer
        setTimeout(() => {
          generateBossSentence(currentBoss.pattern);
        }, 1500);
      };

      // Epic Boss Battle System Functions
      const getComboMultiplier = () => {
        if (battleCombo >= 10) return 3;
        if (battleCombo >= 5) return 2;
        if (battleCombo >= 3) return 1.5;
        return 1;
      };

      const playAttackAnimation = () => {
        setShowAttackEffect(true);
        setTimeout(() => setShowAttackEffect(false), 500);
      };

      const playDamageAnimation = () => {
        setBossAttacking(true);
        setTimeout(() => setBossAttacking(false), 1000);
      };

      const showDamageNumber = (damage) => {
        setLastDamage(damage);
        setShowDamageNumbers(true);
        setTimeout(() => setShowDamageNumbers(false), 1500);
      };

      const updateBossPhase = (health) => {
        if (health > 70) setBossPhase(1);
        else if (health > 40) setBossPhase(2);
        else setBossPhase(3);
      };

      const handleCorrectAnswer = () => {
        const newCombo = battleCombo + 1;
        setBattleCombo(newCombo);
        
        const actualDamage = battleDamage * getComboMultiplier();
        const newBossHealth = Math.max(0, bossHealth - actualDamage);
        setBossHealth(newBossHealth);
        
        // Update stats
        setBattleStats(prev => ({
          ...prev,
          questionsAnswered: prev.questionsAnswered + 1,
          correctAnswers: prev.correctAnswers + 1,
          maxCombo: Math.max(prev.maxCombo, newCombo)
        }));
        
        // Trigger effects
        playAttackAnimation();
        showDamageNumber(actualDamage);
        updateBossPhase(newBossHealth);
        
        // Check for power-ups
        if (newCombo === 5) {
          addPowerUp('shield');
        }
        if (newCombo === 10) {
          addPowerUp('double');
        }
        
        if (newBossHealth <= 0) {
          handleVictory();
        } else {
          // Generate next question after delay
          setTimeout(() => {
            generateBossSentence(currentBoss.pattern);
          }, 1500);
        }
      };

      const handleWrongAnswer = () => {
        setBattleCombo(0); // Reset combo
        setPlayerHealth(prev => prev - 1);
        
        // Update stats
        setBattleStats(prev => ({
          ...prev,
          questionsAnswered: prev.questionsAnswered + 1
        }));
        
        // Trigger effects
        playDamageAnimation();
        
        if (playerHealth - 1 <= 0) {
          handleDefeat();
        } else {
          // Generate new question after delay
          setTimeout(() => {
            generateBossSentence(currentBoss.pattern);
          }, 1500);
        }
      };

      const addPowerUp = (type) => {
        const powerUp = { id: Date.now(), type, used: false };
        setActivePowerUps(prev => [...prev, powerUp]);
      };

      const usePowerUp = (powerUp) => {
        setActivePowerUps(prev => prev.filter(p => p.id !== powerUp.id));
        
        switch (powerUp.type) {
          case 'shield':
            setPlayerHealth(prev => Math.min(5, prev + 1));
            break;
          case 'skip':
            generateBossSentence(currentBoss.pattern);
            break;
          case 'hint':
            // Show hint (implement hint system)
            break;
          case 'double':
            setBattleDamage(prev => prev * 2);
            setTimeout(() => setBattleDamage(10), 30000); // 30 seconds
            break;
        }
      };

      const handleVictory = () => {
        const endTime = Date.now();
        const timeElapsed = battleStartTime ? Math.round((endTime - battleStartTime) / 1000) : 0;
        
        setBattleStats(prev => ({
          ...prev,
          timeElapsed
        }));
        
        setScreen('boss-victory');
      };

      const handleDefeat = () => {
        const endTime = Date.now();
        const timeElapsed = battleStartTime ? Math.round((endTime - battleStartTime) / 1000) : 0;
        
        setBattleStats(prev => ({
          ...prev,
          timeElapsed
        }));
        
        setScreen('boss-defeat');
      };

      const getBossTaunt = (situation) => {
        const taunts = {
          start: ["네 실력을 보여줘!", "준비됐니?", "Let's begin!"],
          hit: ["아야!", "Lucky shot!", "으윽..."],
          phase2: ["이제 진짜 시작이야!", "Getting serious!", "아직 멀었어!"],
          phase3: ["화났어!", "RAGE MODE!", "더 이상은 안돼!"],
          playerHit: ["하하!", "Too slow!", "그것밖에 안돼?"],
          nearDefeat: ["안돼...!", "Impossible!", "이럴 수가..."]
        };
        
        return taunts[situation][Math.floor(Math.random() * taunts[situation].length)];
      };

      // Test System Functions
      const startTest = (tier) => {
        console.log('startTest called with tier:', tier);
        console.log('grammarPatterns:', grammarPatterns);
        
        if (!grammarPatterns?.[tier]) {
          console.log('No patterns found for tier:', tier);
          return;
        }
        
        const patterns = grammarPatterns[tier];
        console.log('Patterns for tier:', patterns);
        
        const testConfig = {
          beginner: { questions: 20, timeLimit: 600 }, // 10 minutes
          intermediate: { questions: 25, timeLimit: 720 }, // 12 minutes
          advanced: { questions: 30, timeLimit: 900 } // 15 minutes
        };
        
        const config = testConfig[tier];
        console.log('Test config:', config);
        
        try {
          const questions = generateTestQuestions(patterns, config.questions, tier);
          console.log('Generated questions:', questions);
          
          setTestMode(tier);
          setTestQuestions(questions);
          setCurrentTestQuestion(0);
          setTestAnswers([]);
          setTestStartTime(Date.now());
          setTestTimeLimit(config.timeLimit);
          setTestTimeRemaining(config.timeLimit);
          setTestScore(0);
          setTestStreak(0);
          setTestResults(null);
          setTestInProgress(true);
          setScreen('test-mode');
          
          // Start timer
          const timer = setInterval(() => {
            setTestTimeRemaining(prev => {
              if (prev <= 1) {
                clearInterval(timer);
                finishTest();
                return 0;
              }
              return prev - 1;
            });
          }, 1000);
        } catch (error) {
          console.error('Error starting test:', error);
          alert('Error starting test: ' + error.message);
        }
      };

      const generateTestQuestions = (patterns, questionCount, tier) => {
        const questions = [];
        const questionTypes = ['recognition', 'construction', 'translation', 'context', 'correction'];
        
        // Ensure we cover all patterns
        const patternsToUse = [...patterns];
        const questionsPerPattern = Math.ceil(questionCount / patterns.length);
        
        patternsToUse.forEach((pattern, patternIndex) => {
          for (let i = 0; i < questionsPerPattern && questions.length < questionCount; i++) {
            const questionType = questionTypes[Math.floor(Math.random() * questionTypes.length)];
            const difficulty = i < questionsPerPattern * 0.3 ? 'easy' : 
                              i < questionsPerPattern * 0.8 ? 'medium' : 'hard';
            
            questions.push(generateQuestion(pattern, questionType, difficulty, tier));
          }
        });
        
        // Shuffle and trim to exact count
        return shuffleArray(questions).slice(0, questionCount);
      };

      const generateQuestion = (pattern, type, difficulty, tier) => {
        try {
          console.log('generateQuestion called with:', { pattern: pattern.name, type, difficulty, tier });
          
          // Try different sentence sources
          let sentences = [];
          if (pattern.sentences?.normal) {
            sentences = pattern.sentences.normal;
          } else if (pattern.sentences?.past) {
            sentences = pattern.sentences.past;
          } else if (pattern.sentences?.present) {
            sentences = pattern.sentences.present;
          } else if (Array.isArray(pattern.sentences)) {
            sentences = pattern.sentences;
          } else {
            console.warn('No sentences found for pattern:', pattern.name);
            // Create a fallback sentence
            sentences = [{
              korean: '예시 문장',
              meaning: 'Example sentence',
              parts: ['예시', '문장']
            }];
          }
          
          if (sentences.length === 0) {
            console.warn('Empty sentences array for pattern:', pattern.name);
            sentences = [{
              korean: '예시 문장',
              meaning: 'Example sentence',
              parts: ['예시', '문장']
            }];
          }
          
          const randomSentence = sentences[Math.floor(Math.random() * sentences.length)];
          console.log('Using sentence:', randomSentence);
          
          switch (type) {
            case 'recognition':
              return generateRecognitionQuestion(pattern, randomSentence, difficulty);
            case 'construction':
              return generateConstructionQuestion(pattern, randomSentence, difficulty);
            case 'translation':
              return generateTranslationQuestion(pattern, randomSentence, difficulty);
            case 'context':
              return generateContextQuestion(pattern, randomSentence, difficulty);
            case 'correction':
              return generateCorrectionQuestion(pattern, randomSentence, difficulty);
            default:
              return generateTranslationQuestion(pattern, randomSentence, difficulty);
          }
        } catch (error) {
          console.error('Error generating question:', error);
          // Return a fallback question
          return {
            id: Date.now() + Math.random(),
            type: 'translation',
            difficulty,
            patternId: pattern.id,
            question: `Translate to Korean: "Example sentence"`,
            correct: '예시 문장',
            explanation: 'This is a fallback question',
            points: 10
          };
        }
      };

      const generateRecognitionQuestion = (pattern, sentence, difficulty) => {
        const wrongPatterns = Object.values(grammarPatterns)
          .flat()
          .filter(p => p.id !== pattern.id)
          .slice(0, 3);
        
        const options = shuffleArray([pattern, ...wrongPatterns]).slice(0, 4);
        
        return {
          id: Date.now() + Math.random(),
          type: 'recognition',
          difficulty,
          patternId: pattern.id,
          question: `Which grammar pattern is used in: "${sentence.korean}"`,
          options: options.map(p => ({ id: p.id, text: p.name })),
          correct: pattern.id,
          explanation: `This sentence uses the ${pattern.name} pattern.`,
          points: difficulty === 'easy' ? 10 : difficulty === 'medium' ? 15 : 20
        };
      };

      const generateConstructionQuestion = (pattern, sentence, difficulty) => {
        const correctParts = [...sentence.parts];
        const distractors = getDistractors(tier);
        const shuffledParts = shuffleArray([...correctParts, ...distractors.slice(0, 3)]);
        
        return {
          id: Date.now() + Math.random(),
          type: 'construction',
          difficulty,
          patternId: pattern.id,
          question: `Arrange these words to make a correct sentence: "${sentence.meaning}"`,
          parts: shuffledParts,
          correct: correctParts.join(' '),
          explanation: `Correct order: ${correctParts.join(' ')}`,
          points: difficulty === 'easy' ? 15 : difficulty === 'medium' ? 20 : 25
        };
      };

      const generateTranslationQuestion = (pattern, sentence, difficulty) => {
        return {
          id: Date.now() + Math.random(),
          type: 'translation',
          difficulty,
          patternId: pattern.id,
          question: `Translate to Korean: "${sentence.meaning}"`,
          correct: sentence.korean,
          explanation: `Correct answer: ${sentence.korean}`,
          points: difficulty === 'easy' ? 20 : difficulty === 'medium' ? 25 : 30
        };
      };

      const generateContextQuestion = (pattern, sentence, difficulty) => {
        const contexts = [
          { situation: "At school", options: [sentence.korean, "안녕하세요", "감사합니다", "죄송합니다"] },
          { situation: "With friends", options: [sentence.korean, "안녕", "고마워", "미안해"] },
          { situation: "At work", options: [sentence.korean, "네, 알겠습니다", "안녕히 가세요", "수고하세요"] }
        ];
        
        const context = contexts[Math.floor(Math.random() * contexts.length)];
        
        return {
          id: Date.now() + Math.random(),
          type: 'context',
          difficulty,
          patternId: pattern.id,
          question: `What would you say in this situation: "${context.situation}"`,
          options: shuffleArray(context.options).map(text => ({ id: text, text })),
          correct: sentence.korean,
          explanation: `In this context, you would say: ${sentence.korean}`,
          points: difficulty === 'easy' ? 15 : difficulty === 'medium' ? 20 : 25
        };
      };

      const generateCorrectionQuestion = (pattern, sentence, difficulty) => {
        // Create a sentence with common mistakes
        const parts = [...sentence.parts];
        const mistakes = [
          [0, 1], // Swap first two words
          [parts.length - 1, parts.length - 2] // Swap last two words
        ];
        
        const mistakeType = mistakes[Math.floor(Math.random() * mistakes.length)];
        const incorrectParts = [...parts];
        [incorrectParts[mistakeType[0]], incorrectParts[mistakeType[1]]] = 
        [incorrectParts[mistakeType[1]], incorrectParts[mistakeType[0]]];
        
        return {
          id: Date.now() + Math.random(),
          type: 'correction',
          difficulty,
          patternId: pattern.id,
          question: `What's wrong with this sentence: "${incorrectParts.join(' ')}"`,
          incorrect: incorrectParts.join(' '),
          correct: sentence.korean,
          explanation: `The correct sentence is: ${sentence.korean}`,
          points: difficulty === 'easy' ? 25 : difficulty === 'medium' ? 30 : 35
        };
      };

      const getDistractors = (tier) => {
        return distractorWords[tier] || distractorWords.beginner;
      };

      const submitTestAnswer = (answer) => {
        const currentQ = testQuestions[currentTestQuestion];
        const isCorrect = answer === currentQ.correct || 
                         (Array.isArray(answer) && answer.join(' ') === currentQ.correct);
        
        const answerData = {
          questionId: currentQ.id,
          answer,
          correct: currentQ.correct,
          isCorrect,
          timeSpent: testTimeLimit - testTimeRemaining,
          points: isCorrect ? currentQ.points : 0
        };
        
        setTestAnswers(prev => [...prev, answerData]);
        
        if (isCorrect) {
          setTestScore(prev => prev + currentQ.points);
          setTestStreak(prev => prev + 1);
        } else {
          setTestStreak(0);
        }
        
        // Reset selected parts for construction questions
        setSelectedTestParts([]);
        
        // Move to next question or finish test
        if (currentTestQuestion < testQuestions.length - 1) {
          setCurrentTestQuestion(prev => prev + 1);
        } else {
          finishTest();
        }
      };

      const finishTest = () => {
        const endTime = Date.now();
        const totalTime = testStartTime ? Math.round((endTime - testStartTime) / 1000) : 0;
        const accuracy = testQuestions.length > 0 ? (testAnswers.filter(a => a.isCorrect).length / testQuestions.length) * 100 : 0;
        
        const results = {
          tier: testMode,
          score: testScore,
          accuracy: Math.round(accuracy),
          timeUsed: totalTime,
          timeLimit: testTimeLimit,
          questionsAnswered: testAnswers.length,
          correctAnswers: testAnswers.filter(a => a.isCorrect).length,
          maxStreak: testStreak,
          breakdown: getTestBreakdown(),
          grade: getTestGrade(accuracy),
          badge: getTestBadge(accuracy, testScore)
        };
        
        setTestResults(results);
        setTestInProgress(false);
        setScreen('test-results');
        
        // Save to localStorage
        const savedTests = JSON.parse(localStorage.getItem('korean-test-results') || '[]');
        savedTests.push(results);
        localStorage.setItem('korean-test-results', JSON.stringify(savedTests));
      };

      const getTestBreakdown = () => {
        const breakdown = {};
        testAnswers.forEach(answer => {
          const patternId = testQuestions.find(q => q.id === answer.questionId)?.patternId;
          if (!breakdown[patternId]) {
            breakdown[patternId] = { correct: 0, total: 0 };
          }
          breakdown[patternId].total++;
          if (answer.isCorrect) breakdown[patternId].correct++;
        });
        return breakdown;
      };

      const getTestGrade = (accuracy) => {
        if (accuracy >= 95) return 'A+';
        if (accuracy >= 90) return 'A';
        if (accuracy >= 85) return 'B+';
        if (accuracy >= 80) return 'B';
        if (accuracy >= 75) return 'C+';
        if (accuracy >= 70) return 'C';
        return 'F';
      };

      const getTestBadge = (accuracy, score) => {
        if (accuracy === 100) return { name: 'Perfectionist', icon: '🏆' };
        if (accuracy >= 95) return { name: 'Grammar Master', icon: '🥇' };
        if (accuracy >= 90) return { name: 'Excellent', icon: '🥈' };
        if (accuracy >= 80) return { name: 'Good Job', icon: '🥉' };
        if (accuracy >= 70) return { name: 'Keep Trying', icon: '📚' };
        return { name: 'Needs Practice', icon: '💪' };
      };

      const shuffleArray = (array) => {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      };

      const setupQuestion = (sentence, tense) => {
        console.log('setupQuestion called with:', sentence, tense);
        
        const correctParts = tense ? [...sentence[tense].parts] : [...sentence.parts];
        console.log('Correct parts:', correctParts);
        
        // Get difficulty from the sentence if available, otherwise use current difficulty
        const currentDifficulty = sentence.difficulty || difficulty || 'beginner';
        console.log('Current difficulty:', currentDifficulty);
        
        const distractors = distractorWords[currentDifficulty];
        console.log('Distractors:', distractors);
        
        const numDistractors = Math.floor(Math.random() * 4) + 5;
        const selectedDistractors = [];
        const shuffledDistractors = shuffleArray([...distractors]);

        for (let i = 0; i < numDistractors && i < shuffledDistractors.length; i++) {
          if (!correctParts.includes(shuffledDistractors[i])) {
            selectedDistractors.push(shuffledDistractors[i]);
          }
        }

        const allParts = [...correctParts, ...selectedDistractors];
        console.log('All parts:', allParts);
        
        setShuffledParts(shuffleArray(allParts));
        setSelectedParts([]);
        setTypedAnswer('');
        setShowFeedback(false);
        setIsCorrect(false);
        
        console.log('setupQuestion completed');
      };

      const startNewSentenceSet = () => {
        const sentences = selectedPattern.sentences[difficulty];
        const randomSentence = sentences[Math.floor(Math.random() * sentences.length)];
        setCurrentSentenceSet(randomSentence);

        if (selectedPattern.tenseVariations) {
          setCurrentTense('past');
          setTensesCompleted([]);
          setupQuestion(randomSentence, 'past');
        } else {
          setCurrentTense(null);
          setupQuestion(randomSentence, null);
        }
      };

      const handlePartClick = (part, index) => {
        if (showFeedback) return;
        setSelectedParts([...selectedParts, part]);
        setShuffledParts(shuffledParts.filter((_, i) => i !== index));
      };

      const handleRemovePart = (index) => {
        if (showFeedback) return;
        const partToRemove = selectedParts[index];
        setShuffledParts([...shuffledParts, partToRemove]);
        setSelectedParts(selectedParts.filter((_, i) => i !== index));
      };

      const checkAnswer = () => {
        let userAnswer;
        let correctAnswer;

        if (selectedPattern.tenseVariations) {
          const currentSentence = currentSentenceSet[currentTense];
          userAnswer = inputMode === 'tap' ? selectedParts.join(' ') : typedAnswer.trim();
          correctAnswer = currentSentence.parts.join(' ');
        } else {
          userAnswer = inputMode === 'tap' ? selectedParts.join(' ') : typedAnswer.trim();
          correctAnswer = currentSentenceSet.parts.join(' ');
        }

        const correct = userAnswer === correctAnswer;
        setIsCorrect(correct);
        setShowFeedback(true);
        setQuestionsAnswered(questionsAnswered + 1);

        // Update heat map (only for regular practice, not boss battles)
        if (!bossBattleMode) {
          updateHeatMap(selectedPattern.id, difficulty, correct);
        }

        if (correct) {
          setScore(score + 1);
          if (selectedPattern.tenseVariations) {
            setTensesCompleted([...tensesCompleted, currentTense]);
          }
          
          // Epic Boss Battle logic
          if (bossBattleMode) {
            handleCorrectAnswer();
          }
        } else {
          // Epic Boss Battle logic for incorrect answers
          if (bossBattleMode) {
            handleWrongAnswer();
          }
        }
      };

      const nextQuestion = () => {
        // Check if we're in Random Mode (no specific tier selected)
        if (!selectedTier) {
          // Generate a new random question
          startRandomMode();
          return;
        }
        
        if (selectedPattern.tenseVariations) {
          if (currentTense === 'past') {
            setCurrentTense('present');
            setupQuestion(currentSentenceSet, 'present');
          } else if (currentTense === 'present') {
            setCurrentTense('future');
            setupQuestion(currentSentenceSet, 'future');
          } else {
            startNewSentenceSet();
          }
        } else {
          startNewSentenceSet();
        }
      };

      const resetToStart = () => {
        setScreen('tier-selection');
        setSelectedTier(null);
        setSelectedPattern(null);
        setDifficulty(null);
        setInputMode(null);
        setCurrentSentenceSet(null);
        setChallengeMode(null);
        setTimeLimit(null);
        setScore(0);
        setStreak(0);
        setQuestionsAnswered(0);
      };

      if (!grammarPatterns) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 flex items-center justify-center">
            <div className="text-2xl text-purple-600">Loading...</div>
          </div>
        );
      }

      if (screen === 'tier-selection') {
        console.log('Rendering tier selection screen');
        
        // Floating Korean characters
        const hangeulChars = ['ㄱ', 'ㄴ', 'ㄷ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅅ', 'ㅇ', 'ㅈ', 'ㅎ', '가', '나', '다', '라', '마'];
        
        console.log('About to render tier selection with hangeul chars:', hangeulChars.length);
        
        return (
          <div className="min-h-screen bg-gradient-to-br from-violet-400 via-fuchsia-300 to-cyan-300 relative overflow-hidden flex items-center justify-center p-4">
            {/* Floating mesh blobs */}
            <div className="absolute inset-0 overflow-hidden">
              <div className="absolute top-20 left-20 w-64 h-64 bg-purple-400 rounded-full mix-blend-multiply filter blur-xl opacity-70 animate-blob"></div>
              <div className="absolute top-40 right-20 w-64 h-64 bg-yellow-400 rounded-full mix-blend-multiply filter blur-xl opacity-70 animate-blob" style={{animationDelay: '2s'}}></div>
              <div className="absolute -bottom-8 left-1/2 w-64 h-64 bg-pink-400 rounded-full mix-blend-multiply filter blur-xl opacity-70 animate-blob" style={{animationDelay: '4s'}}></div>
            </div>
            
            {/* Floating Korean characters */}
            {hangeulChars.map((char, index) => (
              <div
                key={index}
                className="absolute text-white opacity-10 animate-float pointer-events-none"
                style={{
                  left: `${(index * 7) % 100}%`,
                  top: `${(index * 11) % 100}%`,
                  fontSize: `${40 + (index % 6) * 10}px`,
                  animationDelay: `${index * 1.5}s`,
                  animationDuration: `${15 + (index % 5) * 2}s`
                }}
              >
                {char}
              </div>
            ))}
            
            {/* Main glassmorphism card */}
            <div className="relative bg-white/80 backdrop-blur-xl rounded-3xl shadow-2xl border border-white/30 max-w-2xl w-full p-8 md:p-12">
              {/* Header Section */}
              <div className="text-center mb-12">
                {/* Sparkle Icon with animated dots */}
                <div className="relative flex justify-center mb-6">
                  <div className="relative">
                    <Sparkles className="w-20 h-20 text-purple-600 drop-shadow-lg" />
                    <div className="absolute -top-2 -right-2 w-3 h-3 bg-yellow-400 rounded-full animate-ping"></div>
                    <div className="absolute -bottom-2 -left-2 w-3 h-3 bg-pink-400 rounded-full animate-bounce"></div>
                  </div>
                </div>
                
                {/* Main Title with animated gradient */}
                <div className="relative mb-6">
                  <h1 className="text-6xl md:text-7xl font-black text-transparent bg-clip-text bg-gradient-to-r from-purple-600 via-pink-600 to-blue-600 bg-[length:200%_auto] animate-gradient-text">
                    한국어 문법
                  </h1>
                  {/* Pulsing glow effect */}
                  <div className="absolute inset-0 text-6xl md:text-7xl font-black text-purple-600/20 blur-sm animate-pulse">
                    한국어 문법
                  </div>
                </div>
                
                {/* Korean Subtitle Badge */}
                <div className="inline-block mb-6">
                  <div className="bg-gradient-to-r from-purple-100 to-pink-100 border-2 border-purple-200 rounded-full px-6 py-3">
                    <p className="text-purple-900 font-bold text-lg">문법 패턴을 마스터하세요 ✨</p>
                  </div>
                </div>
                
                {/* Call to Action */}
                <p className="text-gray-700 font-medium animate-bounce-subtle">
                  👇 티어를 선택하여 시작하세요 👇
                </p>
              </div>

              {/* Button Grid */}
              <div className="space-y-4">
                <button onClick={() => setScreen('grammar-levels')} className="group w-full bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 text-white font-bold py-6 px-6 rounded-xl transition-all duration-300 hover:scale-[1.02] hover:-translate-y-1 hover:shadow-2xl relative overflow-hidden">
                  <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -skew-x-12 transform -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                  
                  <div className="relative flex items-center justify-center mb-2">
                    <BookOpen className="w-8 h-8 mr-3 drop-shadow-lg animate-twinkle" style={{animationDelay: '0s'}} />
                    <span className="text-3xl font-black drop-shadow-lg group-hover:scale-110 transition-transform duration-300">문법 연습</span>
                  </div>
                  <div className="relative">
                    <div className="text-xs font-semibold uppercase tracking-wider opacity-90 mb-1">Grammar Practice</div>
                    <div className="bg-white/20 backdrop-blur-sm px-4 py-1.5 rounded-full border border-white/30 inline-block">
                      <span className="font-bold drop-shadow">초급 • 중급 • 고급 • 콤보</span>
                    </div>
                  </div>
                </button>

                <button onClick={() => startRandomMode()} className="group w-full bg-gradient-to-r from-indigo-500 to-blue-600 hover:from-indigo-600 hover:to-blue-700 text-white font-bold py-6 px-6 rounded-xl transition-all duration-300 hover:scale-[1.02] hover:-translate-y-1 hover:shadow-2xl relative overflow-hidden">
                  <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -skew-x-12 transform -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                  
                  <div className="relative flex items-center justify-center mb-2">
                    <Zap className="w-8 h-8 mr-3 drop-shadow-lg animate-twinkle" style={{animationDelay: '1.2s'}} />
                    <span className="text-3xl font-black drop-shadow-lg group-hover:scale-110 transition-transform duration-300">랜덤 모드</span>
                  </div>
                  <div className="relative">
                    <div className="text-xs font-semibold uppercase tracking-wider opacity-90 mb-1">Random Mode</div>
                    <div className="bg-white/20 backdrop-blur-sm px-4 py-1.5 rounded-full border border-white/30 inline-block">
                      <span className="font-bold drop-shadow">모든 패턴, 모든 문장!</span>
                    </div>
                  </div>
                </button>

                <button onClick={startBossBattle} className="group w-full bg-gradient-to-r from-red-500 to-pink-600 hover:from-red-600 hover:to-pink-700 text-white font-bold py-6 px-6 rounded-xl transition-all duration-300 hover:scale-[1.02] hover:-translate-y-1 hover:shadow-2xl relative overflow-hidden">
                  <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -skew-x-12 transform -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                  
                  <div className="relative flex items-center justify-center mb-2">
                    <Brain className="w-8 h-8 mr-3 drop-shadow-lg animate-twinkle" style={{animationDelay: '1.5s'}} />
                    <span className="text-3xl font-black drop-shadow-lg group-hover:scale-110 transition-transform duration-300">보스 배틀</span>
                  </div>
                  <div className="relative">
                    <div className="text-xs font-semibold uppercase tracking-wider opacity-90 mb-1">Boss Battle</div>
                    <div className="bg-white/20 backdrop-blur-sm px-4 py-1.5 rounded-full border border-white/30 inline-block">
                      <span className="font-bold drop-shadow">콤보 패턴과 싸우세요!</span>
                    </div>
                  </div>
                </button>

                <button onClick={() => setScreen('must-know-phrases')} className="group w-full bg-gradient-to-r from-teal-500 to-emerald-600 hover:from-teal-600 hover:to-emerald-700 text-white font-bold py-6 px-6 rounded-xl transition-all duration-300 hover:scale-[1.02] hover:-translate-y-1 hover:shadow-2xl relative overflow-hidden">
                  <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -skew-x-12 transform -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                  
                  <div className="relative flex items-center justify-center mb-2">
                    <Star className="w-8 h-8 mr-3 drop-shadow-lg animate-twinkle" style={{animationDelay: '1.8s'}} />
                    <span className="text-3xl font-black drop-shadow-lg group-hover:scale-110 transition-transform duration-300">필수 표현</span>
                  </div>
                  <div className="relative">
                    <div className="text-xs font-semibold uppercase tracking-wider opacity-90 mb-1">Must-Know Phrases</div>
                    <div className="bg-white/20 backdrop-blur-sm px-4 py-1.5 rounded-full border border-white/30 inline-block">
                      <span className="font-bold drop-shadow">일상 대화 표현들</span>
                    </div>
                  </div>
                </button>

                <button onClick={() => setScreen('vocabulary-flashcards')} className="group w-full bg-gradient-to-r from-orange-500 to-red-600 hover:from-orange-600 hover:to-red-700 text-white font-bold py-6 px-6 rounded-xl transition-all duration-300 hover:scale-[1.02] hover:-translate-y-1 hover:shadow-2xl relative overflow-hidden">
                  <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -skew-x-12 transform -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                  
                  <div className="relative flex items-center justify-center mb-2">
                    <Star className="w-8 h-8 mr-3 drop-shadow-lg animate-twinkle" style={{animationDelay: '2.1s'}} />
                    <span className="text-3xl font-black drop-shadow-lg group-hover:scale-110 transition-transform duration-300">어휘 카드</span>
                  </div>
                  <div className="relative">
                    <div className="text-xs font-semibold uppercase tracking-wider opacity-90 mb-1">Vocabulary Flashcards</div>
                    <div className="bg-white/20 backdrop-blur-sm px-4 py-1.5 rounded-full border border-white/30 inline-block">
                      <span className="font-bold drop-shadow">노트북 스타일 학습</span>
                    </div>
                  </div>
                </button>

                <button onClick={() => setScreen('heat-map')} className="group w-full bg-gradient-to-r from-blue-500 to-cyan-600 hover:from-blue-600 hover:to-cyan-700 text-white font-bold py-6 px-6 rounded-xl transition-all duration-300 hover:scale-[1.02] hover:-translate-y-1 hover:shadow-2xl relative overflow-hidden">
                  <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -skew-x-12 transform -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                  
                  <div className="relative flex items-center justify-center mb-2">
                    <Star className="w-8 h-8 mr-3 drop-shadow-lg animate-twinkle" style={{animationDelay: '2.4s'}} />
                    <span className="text-3xl font-black drop-shadow-lg group-hover:scale-110 transition-transform duration-300">히트 맵</span>
                  </div>
                  <div className="relative">
                    <div className="text-xs font-semibold uppercase tracking-wider opacity-90 mb-1">Heat Map</div>
                    <div className="bg-white/20 backdrop-blur-sm px-4 py-1.5 rounded-full border border-white/30 inline-block">
                      <span className="font-bold drop-shadow">진행 상황을 추적하세요</span>
                    </div>
                  </div>
                </button>
              </div>

              {/* Footer */}
              <div className="mt-12 text-center">
                <p className="text-gray-600 font-medium">연습이 완벽을 만든다 · Practice makes perfect</p>
                <div className="flex justify-center mt-3">
                  <Shuffle className="w-6 h-6 text-gray-500" />
                </div>
              </div>
            </div>
          </div>
        );
      }

      if (screen === 'grammar-levels') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-violet-400 via-fuchsia-300 to-cyan-300 relative overflow-hidden flex items-center justify-center p-4">
            {/* Floating mesh blobs */}
            <div className="absolute inset-0 overflow-hidden">
              <div className="absolute top-20 left-20 w-64 h-64 bg-purple-400 rounded-full mix-blend-multiply filter blur-xl opacity-70 animate-blob"></div>
              <div className="absolute top-40 right-20 w-64 h-64 bg-yellow-400 rounded-full mix-blend-multiply filter blur-xl opacity-70 animate-blob" style={{animationDelay: '2s'}}></div>
              <div className="absolute -bottom-8 left-1/2 w-64 h-64 bg-pink-400 rounded-full mix-blend-multiply filter blur-xl opacity-70 animate-blob" style={{animationDelay: '4s'}}></div>
            </div>
            
            {/* Floating Korean characters */}
            {['ㄱ', 'ㄴ', 'ㄷ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅅ', 'ㅇ', 'ㅈ', 'ㅎ', '가', '나', '다', '라', '마'].map((char, index) => (
              <div
                key={index}
                className="absolute text-white/10 text-6xl font-bold pointer-events-none animate-float"
                style={{
                  left: `${Math.random() * 100}%`,
                  top: `${Math.random() * 100}%`,
                  animationDelay: `${Math.random() * 5}s`,
                  animationDuration: `${3 + Math.random() * 4}s`
                }}
              >
                {char}
              </div>
            ))}

            <div className="relative z-10 bg-white/10 backdrop-blur-xl rounded-3xl shadow-2xl p-8 max-w-md w-full border border-white/20">
              {/* Header */}
              <div className="text-center mb-8">
                <div className="flex justify-center mb-4">
                  <BookOpen className="w-16 h-16 text-white drop-shadow-lg" />
                </div>
                <h1 className="text-4xl font-bold text-white mb-2 drop-shadow-lg">
                  문법 레벨 선택
                </h1>
                <p className="text-white/80 font-medium animate-bounce-subtle">
                  👇 레벨을 선택하여 시작하세요 👇
                </p>
              </div>

              {/* Button Grid */}
              <div className="space-y-4">
                <button onClick={() => { setSelectedTier('beginner'); setScreen('pattern-selection'); }} className="group w-full bg-gradient-to-r from-emerald-400 to-emerald-600 hover:from-emerald-500 hover:to-emerald-700 text-white font-bold py-6 px-6 rounded-xl transition-all duration-300 hover:scale-[1.02] hover:-translate-y-1 hover:shadow-2xl relative overflow-hidden">
                  <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -skew-x-12 transform -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                  
                  <div className="relative flex items-center justify-center mb-2">
                    <Star className="w-8 h-8 mr-3 drop-shadow-lg animate-twinkle" style={{animationDelay: '0s'}} />
                    <span className="text-3xl font-black drop-shadow-lg group-hover:scale-110 transition-transform duration-300">초급</span>
                  </div>
                  <div className="relative">
                    <div className="text-xs font-semibold uppercase tracking-wider opacity-90 mb-1">Beginner</div>
                    <div className="bg-white/20 backdrop-blur-sm px-4 py-1.5 rounded-full border border-white/30 inline-block">
                      <span className="font-bold drop-shadow">8개 패턴</span>
                    </div>
                  </div>
                </button>

                <button onClick={() => { setSelectedTier('intermediate'); setScreen('pattern-selection'); }} className="group w-full bg-gradient-to-r from-amber-400 to-amber-600 hover:from-amber-500 hover:to-amber-700 text-white font-bold py-6 px-6 rounded-xl transition-all duration-300 hover:scale-[1.02] hover:-translate-y-1 hover:shadow-2xl relative overflow-hidden">
                  <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -skew-x-12 transform -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                  
                  <div className="relative flex items-center justify-center mb-2">
                    <Star className="w-8 h-8 mr-3 drop-shadow-lg animate-twinkle" style={{animationDelay: '0.3s'}} />
                    <span className="text-3xl font-black drop-shadow-lg group-hover:scale-110 transition-transform duration-300">중급</span>
                  </div>
                  <div className="relative">
                    <div className="text-xs font-semibold uppercase tracking-wider opacity-90 mb-1">Intermediate</div>
                    <div className="bg-white/20 backdrop-blur-sm px-4 py-1.5 rounded-full border border-white/30 inline-block">
                      <span className="font-bold drop-shadow">10개 패턴</span>
                    </div>
                  </div>
                </button>

                <button onClick={() => { setSelectedTier('advanced'); setScreen('pattern-selection'); }} className="group w-full bg-gradient-to-r from-rose-400 to-rose-600 hover:from-rose-500 hover:to-rose-700 text-white font-bold py-6 px-6 rounded-xl transition-all duration-300 hover:scale-[1.02] hover:-translate-y-1 hover:shadow-2xl relative overflow-hidden">
                  <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -skew-x-12 transform -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                  
                  <div className="relative flex items-center justify-center mb-2">
                    <Star className="w-8 h-8 mr-3 drop-shadow-lg animate-twinkle" style={{animationDelay: '0.6s'}} />
                    <span className="text-3xl font-black drop-shadow-lg group-hover:scale-110 transition-transform duration-300">고급</span>
                  </div>
                  <div className="relative">
                    <div className="text-xs font-semibold uppercase tracking-wider opacity-90 mb-1">Advanced</div>
                    <div className="bg-white/20 backdrop-blur-sm px-4 py-1.5 rounded-full border border-white/30 inline-block">
                      <span className="font-bold drop-shadow">10개 패턴</span>
                    </div>
                  </div>
                </button>

                <button onClick={() => { setSelectedTier('combo'); setScreen('pattern-selection'); }} className="group w-full bg-gradient-to-r from-purple-500 to-purple-700 hover:from-purple-600 hover:to-purple-800 text-white font-bold py-6 px-6 rounded-xl transition-all duration-300 hover:scale-[1.02] hover:-translate-y-1 hover:shadow-2xl relative overflow-hidden">
                  <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -skew-x-12 transform -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                  
                  <div className="relative flex items-center justify-center mb-2">
                    <Star className="w-8 h-8 mr-3 drop-shadow-lg animate-twinkle" style={{animationDelay: '0.9s'}} />
                    <span className="text-3xl font-black drop-shadow-lg group-hover:scale-110 transition-transform duration-300">콤보 티어</span>
                  </div>
                  <div className="relative">
                    <div className="text-xs font-semibold uppercase tracking-wider opacity-90 mb-1">Combo Tier</div>
                    <div className="bg-white/20 backdrop-blur-sm px-4 py-1.5 rounded-full border border-white/30 inline-block">
                      <span className="font-bold drop-shadow">5개 결합 패턴</span>
                    </div>
                  </div>
                </button>

                {/* Test Section */}
                <div className="mt-8 pt-6 border-t border-white/20">
                  <div className="text-center mb-6">
                    <h3 className="text-2xl font-bold text-white mb-2">📝 능력 테스트</h3>
                    <p className="text-white/80 text-sm">Test your mastery of each tier</p>
                  </div>
                  
                  <div className="grid grid-cols-3 gap-3">
                    <button onClick={() => startTest('beginner')} className="group bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 hover:scale-105 relative overflow-hidden">
                      <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -skew-x-12 transform -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                      <div className="relative">
                        <div className="text-lg font-black">초급 테스트</div>
                        <div className="text-xs opacity-90">20 questions • 10 min</div>
                      </div>
                    </button>
                    
                    <button onClick={() => startTest('intermediate')} className="group bg-gradient-to-r from-amber-500 to-orange-600 hover:from-amber-600 hover:to-orange-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 hover:scale-105 relative overflow-hidden">
                      <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -skew-x-12 transform -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                      <div className="relative">
                        <div className="text-lg font-black">중급 테스트</div>
                        <div className="text-xs opacity-90">25 questions • 12 min</div>
                      </div>
                    </button>
                    
                    <button onClick={() => startTest('advanced')} className="group bg-gradient-to-r from-red-500 to-pink-600 hover:from-red-600 hover:to-pink-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 hover:scale-105 relative overflow-hidden">
                      <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -skew-x-12 transform -translate-x-full group-hover:translate-x-full transition-transform duration-700"></div>
                      <div className="relative">
                        <div className="text-lg font-black">고급 테스트</div>
                        <div className="text-xs opacity-90">30 questions • 15 min</div>
                      </div>
                    </button>
                  </div>
                </div>
              </div>

              {/* Footer */}
              <div className="mt-8 text-center">
                <button onClick={() => setScreen('tier-selection')} className="flex items-center justify-center text-white/80 hover:text-white transition-colors mx-auto">
                  <ArrowLeft className="w-5 h-5 mr-2" />
                  <span className="font-medium">메인 메뉴로 돌아가기</span>
                </button>
              </div>
            </div>
          </div>
        );
      }

      if (screen === 'heat-map') {
        const stats = getHeatMapStats();
        const hasData = Object.keys(stats).length > 0;
        
        return (
          <div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 flex items-center justify-center p-4">
            <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full max-h-[90vh] overflow-y-auto">
              <button onClick={() => setScreen('tier-selection')} className="flex items-center text-gray-600 hover:text-gray-800 mb-4 transition-colors">
                <ArrowLeft /><span className="ml-2">Back</span>
              </button>
              <h2 className="text-2xl font-bold text-gray-800 mb-6 text-center">Learning Heat Map</h2>
              
              {!hasData ? (
                <div className="text-center py-8">
                  <div className="text-6xl mb-4">📊</div>
                  <p className="text-gray-600 mb-4">No practice data yet!</p>
                  <p className="text-sm text-gray-500">Start practicing grammar patterns to see your progress here.</p>
                </div>
              ) : (
                <>
                  <div className="mb-6 flex justify-between items-center">
                    <p className="text-gray-600">Your practice statistics:</p>
                    <button onClick={resetHeatMap} className="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg text-sm transition-colors">
                      Reset Data
                    </button>
                  </div>
                  
                  <div className="space-y-4">
                    {Object.entries(stats).map(([key, data]) => {
                      const [tier, patternId] = key.split('-');
                      const pattern = grammarPatterns?.[tier]?.find(p => p.id === patternId);
                      const patternName = pattern ? pattern.name : `${tier}-${patternId}`;
                      
                      return (
                        <div key={key} className={`p-4 rounded-xl border-2 ${data.needsWork ? 'border-red-200 bg-red-50' : data.accuracy >= 80 ? 'border-green-200 bg-green-50' : 'border-yellow-200 bg-yellow-50'}`}>
                          <div className="flex justify-between items-start mb-2">
                            <div>
                              <h3 className="font-bold text-lg">{patternName}</h3>
                              <p className="text-sm text-gray-600 capitalize">{tier} level</p>
                            </div>
                            <div className="text-right">
                              <div className={`text-2xl font-bold ${data.needsWork ? 'text-red-600' : data.accuracy >= 80 ? 'text-green-600' : 'text-yellow-600'}`}>
                                {data.accuracy}%
                              </div>
                              <p className="text-xs text-gray-500">{data.practiced} attempts</p>
                            </div>
                          </div>
                          
                          <div className="w-full bg-gray-200 rounded-full h-2 mb-2">
                            <div 
                              className={`h-2 rounded-full ${data.needsWork ? 'bg-red-500' : data.accuracy >= 80 ? 'bg-green-500' : 'bg-yellow-500'}`}
                              style={{ width: `${data.accuracy}%` }}
                            ></div>
                          </div>
                          
                          <div className="flex justify-between text-xs text-gray-600">
                            <span>{data.needsWork ? '⚠️ Needs more practice' : data.accuracy >= 80 ? '🎉 Excellent!' : '📈 Keep practicing!'}</span>
                            <span>{data.correct}/{data.practiced} correct</span>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                  
                  <div className="mt-6 p-4 bg-blue-50 rounded-xl">
                    <h3 className="font-bold text-blue-800 mb-2">Legend:</h3>
                    <div className="grid grid-cols-3 gap-2 text-sm">
                      <div className="flex items-center">
                        <div className="w-3 h-3 bg-green-500 rounded-full mr-2"></div>
                        <span className="text-green-700">80%+ accuracy</span>
                      </div>
                      <div className="flex items-center">
                        <div className="w-3 h-3 bg-yellow-500 rounded-full mr-2"></div>
                        <span className="text-yellow-700">50-79% accuracy</span>
                      </div>
                      <div className="flex items-center">
                        <div className="w-3 h-3 bg-red-500 rounded-full mr-2"></div>
                        <span className="text-red-700">Below 50% accuracy</span>
                      </div>
                    </div>
                  </div>
                </>
              )}
            </div>
          </div>
        );
      }

      if (screen === 'must-know-phrases') {
        const toggleCategory = (categoryKey) => {
          setExpandedCategory(expandedCategory === categoryKey ? null : categoryKey);
        };

        const filteredPhrases = (phrases) => {
          if (!searchTerm) return phrases;
          return phrases.filter(phrase => 
            phrase.english.toLowerCase().includes(searchTerm.toLowerCase()) ||
            phrase.korean.includes(searchTerm)
          );
        };

        // Quiz Mode
        if (phrasesMode === 'quiz') {
          const question = quizQuestions[currentQuestion];
          const isLastQuestion = currentQuestion === quizQuestions.length - 1;
          
          return (
            <div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 flex items-center justify-center p-4">
              <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                {/* Quiz Header */}
                <div className="flex justify-between items-center mb-6">
                  <button onClick={finishQuiz} className="flex items-center text-gray-600 hover:text-gray-800 transition-colors">
                    <ArrowLeft /><span className="ml-2">Exit Quiz</span>
                  </button>
                  <div className="text-right">
                    <div className="text-lg font-bold text-teal-600">Score: {quizScore}/{quizQuestions.length}</div>
                    <div className="text-sm text-gray-500">Question {currentQuestion + 1} of {quizQuestions.length}</div>
                  </div>
                </div>

                {/* Progress Bar */}
                <div className="w-full bg-gray-200 rounded-full h-3 mb-8">
                  <div 
                    className="bg-gradient-to-r from-teal-500 to-emerald-500 h-3 rounded-full transition-all duration-300"
                    style={{ width: `${((currentQuestion + 1) / quizQuestions.length) * 100}%` }}
                  ></div>
                </div>

                {/* Question */}
                <div className="text-center mb-8">
                  <div className="mb-4">
                    <span className={`inline-block px-4 py-2 rounded-full text-sm font-semibold ${
                      question.type === 'english-to-korean' 
                        ? 'bg-blue-100 text-blue-800' 
                        : 'bg-green-100 text-green-800'
                    }`}>
                      {question.type === 'english-to-korean' ? 'English → Korean' : 'Korean → English'}
                    </span>
                  </div>
                  <h2 className="text-3xl font-bold text-gray-800 mb-4">{question.question}</h2>
                  <p className="text-gray-600">Choose the correct translation:</p>
                </div>

                {/* Answer Options */}
                <div className="space-y-3 mb-8">
                  {question.allAnswers.map((answer, index) => {
                    let buttonClass = "w-full p-4 rounded-xl font-semibold text-lg transition-all duration-200 ";
                    
                    if (showAnswer) {
                      if (answer === question.correctAnswer) {
                        buttonClass += "bg-green-500 text-white";
                      } else if (answer === selectedAnswer && answer !== question.correctAnswer) {
                        buttonClass += "bg-red-500 text-white";
                      } else {
                        buttonClass += "bg-gray-200 text-gray-500";
                      }
                    } else {
                      buttonClass += selectedAnswer === answer 
                        ? "bg-teal-500 text-white hover:bg-teal-600" 
                        : "bg-gray-100 text-gray-800 hover:bg-gray-200";
                    }

                    return (
                      <button
                        key={index}
                        onClick={() => handleQuizAnswer(answer)}
                        disabled={showAnswer}
                        className={buttonClass}
                      >
                        {answer}
                      </button>
                    );
                  })}
                </div>

                {/* Feedback */}
                {showAnswer && (
                  <div className={`p-4 rounded-xl mb-6 ${
                    selectedAnswer === question.correctAnswer 
                      ? 'bg-green-100 border-2 border-green-300' 
                      : 'bg-red-100 border-2 border-red-300'
                  }`}>
                    <div className="text-center">
                      <div className="text-2xl mb-2">
                        {selectedAnswer === question.correctAnswer ? '✅' : '❌'}
                      </div>
                      <p className={`font-bold ${
                        selectedAnswer === question.correctAnswer ? 'text-green-800' : 'text-red-800'
                      }`}>
                        {selectedAnswer === question.correctAnswer 
                          ? 'Correct!' 
                          : `Wrong! The correct answer is: ${question.correctAnswer}`
                        }
                      </p>
                    </div>
                  </div>
                )}

                {/* Next Button */}
                {showAnswer && (
                  <div className="text-center">
                    {isLastQuestion ? (
                      <button
                        onClick={finishQuiz}
                        className="bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-8 rounded-xl transition-colors"
                      >
                        Finish Quiz ({quizScore}/{quizQuestions.length})
                      </button>
                    ) : (
                      <button
                        onClick={nextQuizQuestion}
                        className="bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-8 rounded-xl transition-colors"
                      >
                        Next Question
                      </button>
                    )}
                  </div>
                )}
              </div>
            </div>
          );
        }

        // Flashcard Mode
        if (phrasesMode === 'flashcards') {
          const phrase = flashcardPhrases[currentFlashcard];
          const isLastCard = currentFlashcard === flashcardPhrases.length - 1;
          const isLearned = learnedPhrases[phrase.english + phrase.korean];

          return (
            <div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 flex items-center justify-center p-4">
              <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-2xl w-full">
                {/* Flashcard Header */}
                <div className="flex justify-between items-center mb-6">
                  <button onClick={() => setPhrasesMode('browse')} className="flex items-center text-gray-600 hover:text-gray-800 transition-colors">
                    <ArrowLeft /><span className="ml-2">Exit Flashcards</span>
                  </button>
                  <div className="text-right">
                    <div className="text-lg font-bold text-teal-600">
                      Card {currentFlashcard + 1} of {flashcardPhrases.length}
                    </div>
                    <div className="text-sm text-gray-500">
                      {isLearned ? '✅ Learned' : '📚 Learning'}
                    </div>
                  </div>
                </div>

                {/* Progress Bar */}
                <div className="w-full bg-gray-200 rounded-full h-3 mb-8">
                  <div 
                    className="bg-gradient-to-r from-teal-500 to-emerald-500 h-3 rounded-full transition-all duration-300"
                    style={{ width: `${((currentFlashcard + 1) / flashcardPhrases.length) * 100}%` }}
                  ></div>
                </div>

                {/* Flashcard */}
                <div 
                  className="bg-gradient-to-br from-teal-50 to-emerald-50 rounded-2xl p-8 mb-8 min-h-[300px] flex items-center justify-center cursor-pointer hover:shadow-lg transition-all"
                  onClick={flipFlashcard}
                >
                  <div className="text-center">
                    {flashcardSide === 'front' ? (
                      <div>
                        <div className="text-sm text-gray-500 mb-2">English</div>
                        <h2 className="text-3xl font-bold text-gray-800">{phrase.english}</h2>
                        <p className="text-gray-600 mt-4">Tap to reveal Korean translation</p>
                      </div>
                    ) : (
                      <div>
                        <div className="text-sm text-gray-500 mb-2">Korean</div>
                        <h2 className="text-3xl font-bold text-teal-800">{phrase.korean}</h2>
                        <p className="text-gray-600 mt-4">Tap to see English again</p>
                      </div>
                    )}
                  </div>
                </div>

                {/* Action Buttons */}
                <div className="flex justify-center space-x-4 mb-6">
                  <button
                    onClick={() => markPhraseAsLearned(phrase, true)}
                    className={`px-6 py-3 rounded-xl font-semibold transition-colors ${
                      isLearned 
                        ? 'bg-green-500 text-white' 
                        : 'bg-green-100 text-green-700 hover:bg-green-200'
                    }`}
                  >
                    ✅ I Know This
                  </button>
                  <button
                    onClick={() => markPhraseAsLearned(phrase, false)}
                    className="px-6 py-3 rounded-xl font-semibold bg-yellow-100 text-yellow-700 hover:bg-yellow-200 transition-colors"
                  >
                    📚 Need Practice
                  </button>
                </div>

                {/* Navigation */}
                <div className="flex justify-between items-center">
                  <button
                    onClick={previousFlashcard}
                    disabled={currentFlashcard === 0}
                    className="flex items-center px-4 py-2 rounded-lg bg-gray-100 text-gray-700 hover:bg-gray-200 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    <ArrowLeft className="w-4 h-4 mr-2" />
                    Previous
                  </button>

                  <div className="text-center text-gray-600">
                    Tap card to flip
                  </div>

                  <button
                    onClick={nextFlashcard}
                    className="flex items-center px-4 py-2 rounded-lg bg-teal-500 text-white hover:bg-teal-600 transition-colors"
                  >
                    {isLastCard ? 'Finish' : 'Next'}
                    {!isLastCard && <ArrowRight className="w-4 h-4 ml-2" />}
                  </button>
                </div>
              </div>
            </div>
          );
        }

        // Browse Mode (Original)
        return (
          <div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 flex items-center justify-center p-4">
            <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-4xl w-full max-h-[90vh] overflow-y-auto">
              <button onClick={() => setScreen('tier-selection')} className="flex items-center text-gray-600 hover:text-gray-800 mb-6 transition-colors">
                <ArrowLeft /><span className="ml-2">Back to Menu</span>
              </button>
                
                {/* Header */}
                <div className="text-center mb-8">
                  <div className="flex justify-center mb-4">
                    <Sparkles className="w-16 h-16 text-teal-600 drop-shadow-lg" />
                  </div>
                  <h2 className="text-4xl font-bold bg-gradient-to-r from-teal-600 to-emerald-600 bg-clip-text text-transparent mb-2">
                    Must-Know Korean Phrases
                  </h2>
                  <p className="text-gray-600 text-lg">필수 한국어 표현</p>
                  <p className="text-sm text-gray-500 mt-2">Essential phrases for daily conversations</p>
                </div>

              {/* Learning Mode Buttons */}
              <div className="flex justify-center space-x-4 mb-8">
                <button
                  onClick={() => startQuiz()}
                  className="bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-bold py-3 px-6 rounded-xl transition-all duration-300 hover:scale-105 shadow-lg"
                >
                  🧠 Quiz Mode
                </button>
                <button
                  onClick={() => startFlashcards()}
                  className="bg-gradient-to-r from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700 text-white font-bold py-3 px-6 rounded-xl transition-all duration-300 hover:scale-105 shadow-lg"
                >
                  🎴 Flashcard Mode
                </button>
              </div>

              {/* Search Bar */}
              <div className="mb-6">
                <input
                  type="text"
                  placeholder="Search phrases..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="w-full p-4 rounded-xl border-2 border-gray-200 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent text-lg"
                />
              </div>

              {/* Category Cards */}
              <div className="space-y-6">
                {Object.entries(mustKnowPhrases).map(([categoryKey, category]) => (
                  <div key={categoryKey} className="relative">
                    {/* Card */}
                    <div className="bg-gradient-to-br from-white to-gray-50 rounded-2xl shadow-lg border border-gray-200 overflow-hidden hover:shadow-xl transition-shadow">
                      {/* Header */}
                      <div 
                        className="p-6 cursor-pointer hover:bg-gray-50 transition-colors"
                        onClick={() => toggleCategory(categoryKey)}
                      >
                        <div className="flex items-center justify-between">
                          <div className="flex items-center space-x-4">
                            {/* Category Icon */}
                            <div className="w-12 h-12 bg-gradient-to-r from-teal-500 to-emerald-500 rounded-full flex items-center justify-center">
                              <span className="text-white font-bold text-lg">
                                {categoryKey === 'category1' ? '1' : categoryKey === 'category2' ? '2' : '3'}
                              </span>
                            </div>
                            
                            <div>
                              <h3 className="text-xl font-bold text-gray-800">{category.title}</h3>
                              <p className="text-gray-600 text-sm">
                                {category.phrases.length} phrases • Click to {expandedCategory === categoryKey ? 'collapse' : 'expand'}
                              </p>
                            </div>
                          </div>
                          
                          {/* Category-specific Quiz/Flashcard buttons */}
                          <div className="flex space-x-2">
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                startQuiz(categoryKey);
                              }}
                              className="px-3 py-1 bg-blue-100 text-blue-700 rounded-lg text-sm hover:bg-blue-200 transition-colors"
                            >
                              Quiz
                            </button>
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                startFlashcards(categoryKey);
                              }}
                              className="px-3 py-1 bg-purple-100 text-purple-700 rounded-lg text-sm hover:bg-purple-200 transition-colors"
                            >
                              Cards
                            </button>
                          </div>
                          
                          {/* Chevron */}
                          <div className={`transform transition-transform duration-300 ${expandedCategory === categoryKey ? 'rotate-180' : ''}`}>
                            <svg className="w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                            </svg>
                          </div>
                        </div>
                      </div>

                      {/* Expanded Content */}
                      <div className={`transition-all duration-500 ease-in-out overflow-hidden ${expandedCategory === categoryKey ? 'max-h-[800px] opacity-100' : 'max-h-0 opacity-0'}`}>
                        <div className="px-6 pb-6">
                          <div className="bg-gray-50 rounded-xl p-6">
                            {/* Phrases List */}
                            <div className="space-y-3">
                              {filteredPhrases(category.phrases).map((phrase, index) => {
                                const isLearned = learnedPhrases[phrase.english + phrase.korean];
                                return (
                                  <div key={index} className={`flex justify-between items-center py-3 px-4 hover:bg-white hover:shadow-md rounded-lg transition-all group ${
                                    isLearned ? 'bg-green-50 border border-green-200' : ''
                                  }`}>
                                    <span className="font-medium text-gray-800 flex items-center">
                                      {isLearned && <span className="text-green-500 mr-2">✅</span>}
                                      <span className="w-2 h-2 bg-teal-400 rounded-full mr-3 opacity-0 group-hover:opacity-100 transition-opacity"></span>
                                      {phrase.english}
                                    </span>
                                    <span className="font-semibold text-teal-700 bg-teal-100 px-3 py-1 rounded-lg text-sm">
                                      {phrase.korean}
                                    </span>
                                  </div>
                                );
                              })}
                            </div>
                            
                            {filteredPhrases(category.phrases).length === 0 && searchTerm && (
                              <div className="text-center py-8 text-gray-500">
                                <p>No phrases found matching "{searchTerm}"</p>
                              </div>
                            )}
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>

              {/* Footer Info */}
              <div className="mt-8 text-center">
                <p className="text-gray-600 text-sm">💡 Tip: Use Quiz Mode for testing and Flashcard Mode for studying</p>
              </div>
            </div>
          </div>
        );
      }

      if (screen === 'vocabulary-flashcards') {
        // Loading state
        if (vocabularyCards.length === 0) {
          return (
            <div className="min-h-screen relative">
              <div className="page-background"></div>
              <div className="gradient-mesh">
                <div className="blob-1"></div>
                <div className="blob-2"></div>
                <div className="blob-3"></div>
              </div>
              {renderFloatingCharacters()}
              
              <div className="content-container">
                <div className="glass-card max-w-md">
                  <button onClick={() => setScreen('tier-selection')} className="btn-secondary mb-6">
                    <ArrowLeft /><span className="ml-2">Back to Menu</span>
                  </button>
                  <div className="text-center">
                    <div className="loading-spinner mx-auto mb-4"></div>
                    <h2 className="text-2xl font-bold gradient-text mb-4">Loading Vocabulary...</h2>
                    <p className="text-gray-600">Please wait while we load the vocabulary cards.</p>
                  </div>
                </div>
              </div>
            </div>
          );
        }

        const currentCard = vocabularyCards[currentVocabularyCard];
        const isFirstCard = currentVocabularyCard === 0;
        const isLastCard = currentVocabularyCard === vocabularyCards.length - 1;

        return (
          <div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 flex items-center justify-center p-4">
            <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-4xl w-full">
                {/* Header */}
                <div className="flex justify-between items-center mb-8">
                  <button onClick={() => setScreen('tier-selection')} className="flex items-center text-gray-600 hover:text-gray-800 transition-colors">
                    <ArrowLeft /><span className="ml-2">Back to Menu</span>
                  </button>
                  <div className="text-center">
                    <h2 className="text-3xl font-bold bg-gradient-to-r from-orange-600 to-red-600 bg-clip-text text-transparent">
                      Vocabulary Flashcards
                    </h2>
                    <p className="text-gray-600">어휘 플래시카드</p>
                  </div>
                  <div className="text-right">
                    <div className="text-lg font-bold text-orange-600">
                      Card {currentVocabularyCard + 1} of {vocabularyCards.length}
                    </div>
                  </div>
                </div>

              {/* Flashcard Container */}
              <div className="flex justify-center items-center mb-8">
                <div className="relative w-full max-w-2xl">
                  {/* Navigation Buttons */}
                  <button
                    onClick={handleVocabularyPrev}
                    disabled={isFirstCard}
                    className={`absolute left-4 top-1/2 transform -translate-y-1/2 z-10 w-12 h-12 rounded-full flex items-center justify-center transition-all ${
                      isFirstCard 
                        ? 'bg-gray-200 text-gray-400 cursor-not-allowed' 
                        : 'bg-white text-orange-600 hover:bg-orange-50 shadow-lg hover:scale-110'
                    }`}
                  >
                    <ArrowLeft className="w-6 h-6" />
                  </button>

                  <button
                    onClick={handleVocabularyNext}
                    disabled={isLastCard}
                    className={`absolute right-4 top-1/2 transform -translate-y-1/2 z-10 w-12 h-12 rounded-full flex items-center justify-center transition-all ${
                      isLastCard 
                        ? 'bg-gray-200 text-gray-400 cursor-not-allowed' 
                        : 'bg-white text-orange-600 hover:bg-orange-50 shadow-lg hover:scale-110'
                    }`}
                  >
                    <ArrowRight className="w-6 h-6" />
                  </button>

                  {/* Simple Flashcard */}
                  <div 
                    className="w-full h-[600px] cursor-pointer bg-gradient-to-br from-orange-50 to-red-50 rounded-2xl shadow-2xl overflow-hidden border-4 border-orange-200"
                    onClick={handleVocabularyFlip}
                  >
                    {!isVocabularyFlipped ? (
                      /* Front of Card */
                      <div className="relative w-full h-full p-8 flex flex-col items-center justify-center">
                        {/* Spiral Holes */}
                        <div className="absolute left-4 top-0 bottom-0 flex flex-col items-center justify-evenly py-8">
                          {[...Array(12)].map((_, i) => (
                            <div key={i} className="w-2 h-2 bg-gray-400 rounded-full"></div>
                          ))}
                        </div>

                        {/* Page Corner */}
                        <div className="absolute top-4 right-4 w-8 h-8 bg-gray-300 transform rotate-45"></div>

                        {/* Page Counter */}
                        <div className="absolute top-4 right-16 bg-gray-600 text-white px-3 py-1 rounded-full text-sm font-bold">
                          {currentVocabularyCard + 1}/{vocabularyCards.length}
                        </div>

                        {/* LEARN KOREAN WITH KELLY */}
                        <div className="absolute top-4 right-32 text-xs text-gray-600 font-mono">
                          LEARN KOREAN WITH KELLY
                        </div>

                        {/* Main Content */}
                        <div className="text-center">
                          {/* Red Circle Stamp */}
                          <div className="inline-block border-4 border-red-500 rounded-full p-6 transform -rotate-3 mb-6">
                            <div className="text-5xl font-black text-gray-800">
                              {currentCard.word}
                            </div>
                          </div>
                          
                          {/* Romanization */}
                          <div className="text-xl text-gray-600 font-medium mb-8">
                            ({currentCard.romanization})
                          </div>
                          
                          {/* Flip Hint */}
                          <div className="text-gray-500 text-lg">
                            💡 Click to see meaning and examples
                          </div>
                        </div>

                        {/* Mute Button */}
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            toggleVocabularyMute();
                          }}
                          className="absolute bottom-4 right-4 w-10 h-10 bg-gray-600 hover:bg-gray-700 rounded-full flex items-center justify-center text-white transition-all"
                        >
                          🔊
                        </button>
                      </div>
                    ) : (
                      /* Back of Card */
                      <div className="relative w-full h-full p-8 overflow-y-auto">
                        {/* Spiral Holes */}
                        <div className="absolute left-4 top-0 bottom-0 flex flex-col items-center justify-evenly py-8">
                          {[...Array(12)].map((_, i) => (
                            <div key={i} className="w-2 h-2 bg-gray-400 rounded-full"></div>
                          ))}
                        </div>

                        {/* Page Corner */}
                        <div className="absolute top-4 right-4 w-8 h-8 bg-gray-300 transform rotate-45"></div>

                        {/* Page Counter */}
                        <div className="absolute top-4 right-16 bg-gray-600 text-white px-3 py-1 rounded-full text-sm font-bold">
                          {currentVocabularyCard + 1}/{vocabularyCards.length}
                        </div>

                        {/* LEARN KOREAN WITH KELLY */}
                        <div className="absolute top-4 right-32 text-xs text-gray-600 font-mono">
                          LEARN KOREAN WITH KELLY
                        </div>

                        {/* Main Content */}
                        <div className="mt-12">
                          {/* Word Header */}
                          <div className="flex items-center mb-6">
                            <span className="text-2xl mr-3">⏰</span>
                            <div>
                              <div className="text-3xl font-bold text-gray-800">
                                {currentCard.word} ({currentCard.romanization})
                              </div>
                              <div className="text-xl font-semibold text-orange-600 mt-1">
                                = {currentCard.meaning}
                              </div>
                            </div>
                          </div>

                          {/* Description */}
                          <div className="mb-6">
                            <div className="font-semibold text-gray-800 mb-3">Meaning:</div>
                            <ul className="space-y-2">
                              {currentCard.description.map((desc, index) => (
                                <li key={index} className="flex items-start">
                                  <span className="w-2 h-2 bg-gray-400 rounded-full mt-2 mr-3 flex-shrink-0"></span>
                                  <span className="text-gray-700 leading-relaxed">{desc}</span>
                                </li>
                              ))}
                            </ul>
                          </div>

                          {/* Examples */}
                          <div>
                            <div className="font-bold text-gray-800 mb-4">Examples:</div>
                            <div className="space-y-4">
                              {currentCard.examples.map((example, index) => (
                                <div key={index} className="bg-white bg-opacity-70 p-4 rounded-lg border border-orange-200">
                                  <div className="text-lg font-medium text-gray-800 mb-1">
                                    {example.korean}
                                  </div>
                                  <div className="flex items-center">
                                    <span className="text-gray-400 mr-2">→</span>
                                    <span className="text-gray-600">{example.english}</span>
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        </div>

                        {/* Mute Button */}
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            toggleVocabularyMute();
                          }}
                          className="absolute bottom-4 right-4 w-10 h-10 bg-gray-600 hover:bg-gray-700 rounded-full flex items-center justify-center text-white transition-all"
                        >
                          🔊
                        </button>
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {/* Footer Info */}
              <div className="text-center">
                <p className="text-gray-600 text-sm mb-2">
                  💡 Click the card to flip between front and back
                </p>
                <p className="text-gray-500 text-xs">
                  Use arrow buttons to navigate between cards
                </p>
              </div>
            </div>
          </div>
        );
      }

      if (screen === 'boss-battle') {
        if (!currentBoss || !currentSentenceSet) {
          return (
            <div className="min-h-screen bg-gradient-to-br from-red-50 to-orange-100 flex items-center justify-center p-4">
              <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full text-center">
                <div className="text-6xl mb-4">🔥</div>
                <h2 className="text-2xl font-bold text-gray-800 mb-4">Boss Battle Loading...</h2>
                <button onClick={() => setScreen('tier-selection')} className="bg-gray-500 hover:bg-gray-600 text-white px-6 py-2 rounded-lg transition-colors">
                  Back to Menu
                </button>
              </div>
            </div>
          );
        }

        const currentSentence = currentSentenceSet;

        return (
          <div className={`min-h-screen relative overflow-hidden flex flex-col p-4 transition-all duration-1000 ${
            bossPhase === 1 ? 'bg-gradient-to-br from-purple-600 via-blue-600 to-indigo-700' :
            bossPhase === 2 ? 'bg-gradient-to-br from-orange-500 via-red-500 to-pink-600' :
            'bg-gradient-to-br from-red-700 via-purple-800 to-black'
          }`}>
            {/* Background Effects */}
            <div className="absolute inset-0 overflow-hidden">
              <div className="absolute top-10 left-10 w-32 h-32 bg-white/10 rounded-full blur-xl animate-pulse"></div>
              <div className="absolute top-20 right-20 w-48 h-48 bg-yellow-400/20 rounded-full blur-xl animate-pulse" style={{animationDelay: '1s'}}></div>
              <div className="absolute bottom-20 left-1/3 w-40 h-40 bg-red-400/20 rounded-full blur-xl animate-pulse" style={{animationDelay: '2s'}}></div>
            </div>

            {/* Boss Character */}
            <div className="flex-1 flex items-center justify-center relative z-10">
              <div className="text-center">
                {/* Boss Name Plate */}
                <div className="mb-6">
                  <h1 className="text-4xl font-black text-white drop-shadow-lg mb-2">
                    {currentBoss.name}
                  </h1>
                  <div className="bg-white/20 backdrop-blur-sm rounded-full px-6 py-2 border border-white/30 inline-block">
                    <span className="text-white font-bold">Lv. 50 • {currentBoss.specialAbility}</span>
                  </div>
                </div>

                {/* Boss Sprite */}
                <div className={`boss-sprite mb-6 transition-all duration-500 ${bossAttacking ? 'attacking' : ''} ${
                  bossHealth > 70 ? 'confident' : bossHealth > 40 ? 'worried' : 'angry'
                }`}>
                  <div className="text-9xl mb-4 drop-shadow-2xl">
                    {bossPhase === 1 ? '🐉' : bossPhase === 2 ? '🔥' : '👹'}
                  </div>
                  {bossAttacking && (
                    <div className="boss-dialogue bg-red-600 text-white px-4 py-2 rounded-lg mb-4 inline-block">
                      <p className="font-bold">{getBossTaunt('playerHit')}</p>
                    </div>
                  )}
                </div>

                {/* Boss Health Bar */}
                <div className="boss-health-container mb-6">
                  <div className="bg-white/20 backdrop-blur-sm rounded-full px-6 py-3 border border-white/30">
                    <div className="text-white font-bold mb-2">BOSS HEALTH</div>
                    <div className="w-80 h-6 bg-red-900/50 rounded-full overflow-hidden border-2 border-white/30">
                      <div 
                        className={`h-full transition-all duration-500 ${
                          bossHealth > 70 ? 'bg-gradient-to-r from-green-500 to-green-400' :
                          bossHealth > 40 ? 'bg-gradient-to-r from-yellow-500 to-yellow-400' :
                          'bg-gradient-to-r from-red-500 to-red-400'
                        }`}
                        style={{ width: `${bossHealth}%` }}
                      >
                        <span className="text-white font-black text-sm flex items-center justify-center h-full">
                          {bossHealth}%
                        </span>
                      </div>
                    </div>
                  </div>
                </div>

                {/* Damage Numbers */}
                {showDamageNumbers && (
                  <div className="damage-number absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
                    -{lastDamage}
                  </div>
                )}

                {/* Attack Effect */}
                {showAttackEffect && (
                  <div className="attack-effect absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-full h-20 bg-gradient-to-r from-transparent via-yellow-400 to-transparent opacity-80"></div>
                )}
              </div>
            </div>

            {/* VS Divider */}
            <div className="flex justify-center items-center mb-8 relative z-10">
              <div className="bg-white/20 backdrop-blur-sm rounded-full px-8 py-4 border border-white/30">
                <span className="text-white font-black text-2xl">VS</span>
              </div>
            </div>

            {/* Player Stats */}
            <div className="flex justify-center mb-8 relative z-10">
              <div className="bg-white/20 backdrop-blur-sm rounded-xl px-6 py-4 border border-white/30">
                <div className="flex items-center space-x-6">
                  {/* Player Avatar */}
                  <div className="text-4xl">👤</div>
                  
                  {/* Health Hearts */}
                  <div className="flex space-x-1">
                    {[...Array(5)].map((_, i) => (
                      <span key={i} className={`text-2xl ${i < playerHealth ? 'text-red-500' : 'text-gray-400'}`}>
                        {i < playerHealth ? '❤️' : '🖤'}
                      </span>
                    ))}
                  </div>
                  
                  {/* Combo Display */}
                  {battleCombo > 0 && (
                    <div className={`combo-display bg-gradient-to-r px-4 py-2 rounded-lg ${
                      battleCombo >= 10 ? 'from-purple-500 to-pink-500' :
                      battleCombo >= 5 ? 'from-orange-500 to-red-500' :
                      'from-blue-500 to-purple-500'
                    }`}>
                      <span className="text-white font-bold">
                        COMBO x{battleCombo} {battleCombo >= 3 && '🔥'}
                      </span>
                    </div>
                  )}
                  
                  {/* Power-ups */}
                  <div className="flex space-x-2">
                    {activePowerUps.map(powerUp => (
                      <button
                        key={powerUp.id}
                        onClick={() => usePowerUp(powerUp)}
                        className="bg-white/20 hover:bg-white/30 text-white p-2 rounded-lg transition-colors"
                        title={powerUp.type}
                      >
                        {powerUp.type === 'shield' ? '🛡️' :
                         powerUp.type === 'skip' ? '⚡' :
                         powerUp.type === 'hint' ? '🔮' :
                         powerUp.type === 'double' ? '⭐' : '?'}
                      </button>
                    ))}
                  </div>
                </div>
              </div>
            </div>

            {/* Question Section */}
            <div className="bg-white/10 backdrop-blur-xl rounded-3xl shadow-2xl p-6 max-w-2xl mx-auto border border-white/20 relative z-10">
              <div className="mb-4 p-3 bg-blue-500/20 rounded-lg border border-blue-300/30">
                <p className="text-sm font-bold text-white mb-1">⚔️ Attack the boss by translating this:</p>
                <p className="text-lg font-semibold text-white">{currentSentence.meaning}</p>
              </div>
              
              <div className="mb-4">
                <input
                  type="text"
                  value={typedAnswer}
                  onChange={(e) => setTypedAnswer(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && checkAnswer()}
                  placeholder="Type your Korean answer here..."
                  className="w-full px-4 py-3 bg-white/20 border-2 border-white/30 rounded-xl focus:border-white/50 focus:outline-none text-white placeholder-white/70 text-lg"
                />
              </div>

              <button
                onClick={checkAnswer}
                disabled={showFeedback}
                className={`w-full font-bold py-3 px-6 rounded-xl transition-all duration-300 ${
                  showFeedback 
                    ? (isCorrect ? 'bg-green-500 text-white' : 'bg-red-500 text-white')
                    : 'bg-gradient-to-r from-red-500 to-pink-500 hover:from-red-600 hover:to-pink-600 text-white hover:scale-105'
                }`}
              >
                {showFeedback ? (isCorrect ? '✅ HIT!' : '❌ MISS!') : '⚔️ ATTACK!'}
              </button>

              {showFeedback && !isCorrect && (
                <div className="mt-4 p-4 bg-red-500/20 rounded-xl border border-red-300/30">
                  <p className="text-white font-bold mb-2">Correct answer: {currentSentence.parts.join(' ')}</p>
                  <p className="text-white/80">The boss laughs at your mistake!</p>
                </div>
              )}
            </div>

            {/* Flee Button */}
            <div className="mt-6 text-center relative z-10">
              <button 
                onClick={() => { setBossBattleMode(false); setScreen('tier-selection'); setCurrentBoss(null); }} 
                className="text-white/80 hover:text-white font-semibold transition-colors"
              >
                🏃 Flee Battle
              </button>
            </div>
          </div>
        );
      }

      if (screen === 'boss-victory') {
        const accuracy = battleStats.questionsAnswered > 0 ? Math.round((battleStats.correctAnswers / battleStats.questionsAnswered) * 100) : 0;
        
        return (
          <div className="victory-screen min-h-screen bg-gradient-to-br from-yellow-400 via-orange-500 to-red-500 flex items-center justify-center p-4 relative overflow-hidden">
            {/* Confetti Effect */}
            <div className="absolute inset-0 overflow-hidden">
              {[...Array(50)].map((_, i) => (
                <div
                  key={i}
                  className="absolute w-4 h-4 bg-yellow-300 rounded-full animate-bounce"
                  style={{
                    left: `${Math.random() * 100}%`,
                    top: `${Math.random() * 100}%`,
                    animationDelay: `${Math.random() * 3}s`,
                    animationDuration: `${2 + Math.random() * 2}s`
                  }}
                />
              ))}
            </div>
            
            <div className="bg-white/20 backdrop-blur-xl rounded-3xl shadow-2xl p-8 max-w-2xl w-full border border-white/30 text-center relative z-10">
              <h1 className="text-6xl font-black text-white mb-4 drop-shadow-lg">
                🎉 승리! VICTORY! 🎉
              </h1>
              
              <div className="mb-8">
                <div className="text-4xl mb-4">👹💀</div>
                <p className="text-white font-bold text-lg">좋은 싸움이었어... (Good fight...)</p>
              </div>
              
              <div className="bg-white/20 backdrop-blur-sm rounded-xl p-6 mb-8 border border-white/30">
                <h3 className="text-2xl font-bold text-white mb-4">Battle Stats</h3>
                <div className="grid grid-cols-2 gap-4 text-white">
                  <div className="bg-white/10 rounded-lg p-3">
                    <div className="text-3xl mb-1">⏱️</div>
                    <div className="font-bold">{Math.floor(battleStats.timeElapsed / 60)}:{(battleStats.timeElapsed % 60).toString().padStart(2, '0')}</div>
                    <div className="text-sm">Time</div>
                  </div>
                  <div className="bg-white/10 rounded-lg p-3">
                    <div className="text-3xl mb-1">🎯</div>
                    <div className="font-bold">{accuracy}%</div>
                    <div className="text-sm">Accuracy</div>
                  </div>
                  <div className="bg-white/10 rounded-lg p-3">
                    <div className="text-3xl mb-1">🔥</div>
                    <div className="font-bold">x{battleStats.maxCombo}</div>
                    <div className="text-sm">Max Combo</div>
                  </div>
                  <div className="bg-white/10 rounded-lg p-3">
                    <div className="text-3xl mb-1">⭐</div>
                    <div className="font-bold">{battleStats.correctAnswers * 100 + battleStats.maxCombo * 50}</div>
                    <div className="text-sm">Score</div>
                  </div>
                </div>
              </div>
              
              <div className="bg-white/20 backdrop-blur-sm rounded-xl p-6 mb-8 border border-white/30">
                <h3 className="text-2xl font-bold text-white mb-4">보상 (Rewards)</h3>
                <div className="space-y-2 text-white">
                  <div className="flex items-center justify-center space-x-2">
                    <span className="text-2xl">🏆</span>
                    <span className="font-bold">Boss Slayer Badge</span>
                  </div>
                  <div className="flex items-center justify-center space-x-2">
                    <span className="text-2xl">✨</span>
                    <span className="font-bold">+{battleStats.correctAnswers * 100} XP</span>
                  </div>
                  <div className="flex items-center justify-center space-x-2">
                    <span className="text-2xl">🎖️</span>
                    <span className="font-bold">Grammar Master Title</span>
                  </div>
                </div>
              </div>
              
              <div className="space-y-4">
                <button 
                  onClick={() => startBossBattle()} 
                  className="w-full bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-bold py-4 px-6 rounded-xl transition-all duration-300 hover:scale-105"
                >
                  다시 도전! (Play Again)
                </button>
                <button 
                  onClick={() => { setBossBattleMode(false); setScreen('tier-selection'); setCurrentBoss(null); }} 
                  className="w-full bg-white/20 hover:bg-white/30 text-white font-bold py-3 px-6 rounded-xl transition-colors border border-white/30"
                >
                  홈으로 (Home)
                </button>
              </div>
            </div>
          </div>
        );
      }

      if (screen === 'boss-defeat') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-gray-800 via-red-900 to-black flex items-center justify-center p-4">
            <div className="bg-white/20 backdrop-blur-xl rounded-3xl shadow-2xl p-8 max-w-2xl w-full border border-white/30 text-center">
              <h1 className="text-6xl font-black text-white mb-4 drop-shadow-lg">
                💀 패배... DEFEAT 💀
              </h1>
              
              <div className="mb-8">
                <div className="text-4xl mb-4">😵</div>
                <p className="text-white font-bold text-lg">다시 도전해 보세요! You can do it!</p>
              </div>
              
              <div className="bg-white/20 backdrop-blur-sm rounded-xl p-6 mb-8 border border-white/30">
                <h3 className="text-2xl font-bold text-white mb-4">Battle Summary</h3>
                <div className="grid grid-cols-2 gap-4 text-white">
                  <div className="bg-white/10 rounded-lg p-3">
                    <div className="text-3xl mb-1">⏱️</div>
                    <div className="font-bold">{Math.floor(battleStats.timeElapsed / 60)}:{(battleStats.timeElapsed % 60).toString().padStart(2, '0')}</div>
                    <div className="text-sm">Time</div>
                  </div>
                  <div className="bg-white/10 rounded-lg p-3">
                    <div className="text-3xl mb-1">🎯</div>
                    <div className="font-bold">{battleStats.questionsAnswered > 0 ? Math.round((battleStats.correctAnswers / battleStats.questionsAnswered) * 100) : 0}%</div>
                    <div className="text-sm">Accuracy</div>
                  </div>
                  <div className="bg-white/10 rounded-lg p-3">
                    <div className="text-3xl mb-1">🔥</div>
                    <div className="font-bold">x{battleStats.maxCombo}</div>
                    <div className="text-sm">Max Combo</div>
                  </div>
                  <div className="bg-white/10 rounded-lg p-3">
                    <div className="text-3xl mb-1">❌</div>
                    <div className="font-bold">{battleStats.questionsAnswered - battleStats.correctAnswers}</div>
                    <div className="text-sm">Mistakes</div>
                  </div>
                </div>
              </div>
              
              <div className="space-y-4">
                <button 
                  onClick={() => startBossBattle()} 
                  className="w-full bg-gradient-to-r from-red-500 to-pink-500 hover:from-red-600 hover:to-pink-600 text-white font-bold py-4 px-6 rounded-xl transition-all duration-300 hover:scale-105"
                >
                  다시 도전! (Retry)
                </button>
                <button 
                  onClick={() => { setBossBattleMode(false); setScreen('grammar-levels'); setCurrentBoss(null); }} 
                  className="w-full bg-white/20 hover:bg-white/30 text-white font-bold py-3 px-6 rounded-xl transition-colors border border-white/30"
                >
                  연습하기 (Practice)
                </button>
                <button 
                  onClick={() => { setBossBattleMode(false); setScreen('tier-selection'); setCurrentBoss(null); }} 
                  className="w-full bg-white/10 hover:bg-white/20 text-white font-bold py-3 px-6 rounded-xl transition-colors border border-white/20"
                >
                  홈으로 (Home)
                </button>
              </div>
            </div>
          </div>
        );
      }

      if (screen === 'test-mode') {
        if (!testQuestions.length || currentTestQuestion >= testQuestions.length) {
          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
              <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full text-center">
                <div className="text-6xl mb-4">📝</div>
                <h2 className="text-2xl font-bold text-gray-800 mb-4">Test Loading...</h2>
                <button onClick={() => setScreen('grammar-levels')} className="bg-gray-500 hover:bg-gray-600 text-white px-6 py-2 rounded-lg transition-colors">
                  Back to Grammar Levels
                </button>
              </div>
            </div>
          );
        }

        const currentQ = testQuestions[currentTestQuestion];
        const progress = ((currentTestQuestion + 1) / testQuestions.length) * 100;
        const timeMinutes = Math.floor(testTimeRemaining / 60);
        const timeSeconds = testTimeRemaining % 60;

        return (
          <div className="min-h-screen bg-gradient-to-br from-blue-500 via-purple-600 to-indigo-700 relative overflow-hidden">
            {/* Background Effects */}
            <div className="absolute inset-0 overflow-hidden">
              <div className="absolute top-10 left-10 w-32 h-32 bg-white/10 rounded-full blur-xl animate-pulse"></div>
              <div className="absolute top-20 right-20 w-48 h-48 bg-yellow-400/20 rounded-full blur-xl animate-pulse" style={{animationDelay: '1s'}}></div>
              <div className="absolute bottom-20 left-1/3 w-40 h-40 bg-blue-400/20 rounded-full blur-xl animate-pulse" style={{animationDelay: '2s'}}></div>
            </div>

            {/* Header */}
            <div className="relative z-10 p-6">
              <div className="bg-white/20 backdrop-blur-xl rounded-2xl p-4 border border-white/30">
                <div className="flex justify-between items-center mb-4">
                  <div>
                    <h1 className="text-2xl font-bold text-white">
                      {testMode === 'beginner' ? '초급 테스트' : 
                       testMode === 'intermediate' ? '중급 테스트' : '고급 테스트'}
                    </h1>
                    <p className="text-white/80">Question {currentTestQuestion + 1} of {testQuestions.length}</p>
                  </div>
                  <div className="text-right">
                    <div className="text-3xl font-bold text-white">
                      {timeMinutes}:{timeSeconds.toString().padStart(2, '0')}
                    </div>
                    <div className="text-white/80 text-sm">Time Remaining</div>
                  </div>
                </div>
                
                {/* Progress Bar */}
                <div className="w-full bg-white/20 rounded-full h-3 mb-2">
                  <div 
                    className="bg-gradient-to-r from-green-400 to-blue-500 h-3 rounded-full transition-all duration-300"
                    style={{ width: `${progress}%` }}
                  ></div>
                </div>
                
                {/* Score and Streak */}
                <div className="flex justify-between text-white text-sm">
                  <span>Score: {testScore}</span>
                  {testStreak > 0 && <span>Streak: {testStreak} 🔥</span>}
                </div>
              </div>
            </div>

            {/* Question */}
            <div className="relative z-10 px-6 pb-6">
              <div className="bg-white/20 backdrop-blur-xl rounded-2xl p-6 border border-white/30 max-w-4xl mx-auto">
                <div className="mb-4">
                  <div className="flex items-center space-x-2 mb-3">
                    <span className="bg-blue-500 text-white px-3 py-1 rounded-full text-sm font-bold">
                      {currentQ.type.toUpperCase()}
                    </span>
                    <span className={`px-3 py-1 rounded-full text-sm font-bold ${
                      currentQ.difficulty === 'easy' ? 'bg-green-500 text-white' :
                      currentQ.difficulty === 'medium' ? 'bg-yellow-500 text-white' :
                      'bg-red-500 text-white'
                    }`}>
                      {currentQ.difficulty.toUpperCase()}
                    </span>
                  </div>
                  <h2 className="text-xl font-bold text-white mb-4">{currentQ.question}</h2>
                </div>

                {/* Question Content */}
                {currentQ.type === 'recognition' && (
                  <div className="space-y-3">
                    {currentQ.options.map((option, index) => (
                      <button
                        key={option.id}
                        onClick={() => submitTestAnswer(option.id)}
                        className="w-full bg-white/20 hover:bg-white/30 text-white text-left p-4 rounded-xl border border-white/30 transition-colors"
                      >
                        {option.text}
                      </button>
                    ))}
                  </div>
                )}

                {currentQ.type === 'construction' && (
                  <div>
                    {/* Selected words */}
                    <div className="flex flex-wrap gap-2 mb-4">
                      {selectedTestParts.map((part, index) => (
                        <button
                          key={index}
                          onClick={() => setSelectedTestParts(prev => prev.filter((_, i) => i !== index))}
                          className="bg-blue-500 text-white px-4 py-2 rounded-lg border border-blue-300 transition-colors"
                        >
                          {part}
                        </button>
                      ))}
                    </div>
                    
                    {/* Available words */}
                    <div className="flex flex-wrap gap-2 mb-4">
                      {currentQ.parts.filter(part => !selectedTestParts.includes(part)).map((part, index) => (
                        <button
                          key={index}
                          onClick={() => setSelectedTestParts(prev => [...prev, part])}
                          className="bg-white/20 hover:bg-white/30 text-white px-4 py-2 rounded-lg border border-white/30 transition-colors"
                        >
                          {part}
                        </button>
                      ))}
                    </div>
                    
                    <div className="flex justify-between items-center">
                      <p className="text-white/80 text-sm">Click words to build your sentence</p>
                      <button
                        onClick={() => submitTestAnswer(selectedTestParts)}
                        disabled={selectedTestParts.length === 0}
                        className="bg-green-500 hover:bg-green-600 disabled:bg-gray-500 text-white px-4 py-2 rounded-lg transition-colors"
                      >
                        Submit Answer
                      </button>
                    </div>
                  </div>
                )}

                {currentQ.type === 'translation' && (
                  <div>
                    <input
                      type="text"
                      placeholder="Type your Korean answer here..."
                      className="w-full px-4 py-3 bg-white/20 border-2 border-white/30 rounded-xl focus:border-white/50 focus:outline-none text-white placeholder-white/70 text-lg"
                      onKeyPress={(e) => e.key === 'Enter' && submitTestAnswer(e.target.value)}
                    />
                  </div>
                )}

                {currentQ.type === 'context' && (
                  <div className="space-y-3">
                    {currentQ.options.map((option, index) => (
                      <button
                        key={option.id}
                        onClick={() => submitTestAnswer(option.text)}
                        className="w-full bg-white/20 hover:bg-white/30 text-white text-left p-4 rounded-xl border border-white/30 transition-colors"
                      >
                        {option.text}
                      </button>
                    ))}
                  </div>
                )}

                {currentQ.type === 'correction' && (
                  <div>
                    <div className="bg-red-500/20 border border-red-300/30 rounded-xl p-4 mb-4">
                      <p className="text-white font-mono">{currentQ.incorrect}</p>
                    </div>
                    <input
                      type="text"
                      placeholder="Type the corrected sentence..."
                      className="w-full px-4 py-3 bg-white/20 border-2 border-white/30 rounded-xl focus:border-white/50 focus:outline-none text-white placeholder-white/70 text-lg"
                      onKeyPress={(e) => e.key === 'Enter' && submitTestAnswer(e.target.value)}
                    />
                  </div>
                )}

                {/* Skip Button */}
                <div className="mt-6 text-center">
                  <button 
                    onClick={() => submitTestAnswer('')} 
                    className="text-white/60 hover:text-white transition-colors"
                  >
                    Skip Question
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      }

      if (screen === 'test-results') {
        if (!testResults) {
          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
              <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full text-center">
                <div className="text-6xl mb-4">📊</div>
                <h2 className="text-2xl font-bold text-gray-800 mb-4">Loading Results...</h2>
              </div>
            </div>
          );
        }

        const { tier, score, accuracy, timeUsed, timeLimit, grade, badge, breakdown } = testResults;
        const tierName = tier === 'beginner' ? '초급' : tier === 'intermediate' ? '중급' : '고급';

        return (
          <div className="min-h-screen bg-gradient-to-br from-green-400 via-blue-500 to-purple-600 flex items-center justify-center p-4 relative overflow-hidden">
            {/* Background Effects */}
            <div className="absolute inset-0 overflow-hidden">
              {[...Array(30)].map((_, i) => (
                <div
                  key={i}
                  className="absolute w-4 h-4 bg-white/20 rounded-full animate-bounce"
                  style={{
                    left: `${Math.random() * 100}%`,
                    top: `${Math.random() * 100}%`,
                    animationDelay: `${Math.random() * 3}s`,
                    animationDuration: `${2 + Math.random() * 2}s`
                  }}
                />
              ))}
            </div>

            <div className="bg-white/20 backdrop-blur-xl rounded-3xl shadow-2xl p-8 max-w-4xl w-full border border-white/30 text-center relative z-10">
              {/* Header */}
              <div className="mb-8">
                <div className="text-6xl mb-4">{badge.icon}</div>
                <h1 className="text-4xl font-black text-white mb-2">
                  {tierName} 테스트 완료!
                </h1>
                <div className="text-6xl font-bold text-white mb-2">{grade}</div>
                <p className="text-white font-bold text-xl">{badge.name}</p>
              </div>

              {/* Stats Grid */}
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
                <div className="bg-white/20 backdrop-blur-sm rounded-xl p-4 border border-white/30">
                  <div className="text-3xl mb-2">📊</div>
                  <div className="text-2xl font-bold text-white">{accuracy}%</div>
                  <div className="text-white/80 text-sm">Accuracy</div>
                </div>
                <div className="bg-white/20 backdrop-blur-sm rounded-xl p-4 border border-white/30">
                  <div className="text-3xl mb-2">⭐</div>
                  <div className="text-2xl font-bold text-white">{score}</div>
                  <div className="text-white/80 text-sm">Score</div>
                </div>
                <div className="bg-white/20 backdrop-blur-sm rounded-xl p-4 border border-white/30">
                  <div className="text-3xl mb-2">⏱️</div>
                  <div className="text-2xl font-bold text-white">{Math.floor(timeUsed / 60)}:{(timeUsed % 60).toString().padStart(2, '0')}</div>
                  <div className="text-white/80 text-sm">Time Used</div>
                </div>
                <div className="bg-white/20 backdrop-blur-sm rounded-xl p-4 border border-white/30">
                  <div className="text-3xl mb-2">✅</div>
                  <div className="text-2xl font-bold text-white">{testResults.correctAnswers}/{testResults.questionsAnswered}</div>
                  <div className="text-white/80 text-sm">Correct</div>
                </div>
              </div>

              {/* Pattern Breakdown */}
              <div className="bg-white/20 backdrop-blur-sm rounded-xl p-6 mb-8 border border-white/30">
                <h3 className="text-2xl font-bold text-white mb-4">Pattern Performance</h3>
                <div className="space-y-3">
                  {Object.entries(breakdown).map(([patternId, stats]) => {
                    const pattern = grammarPatterns[tier]?.find(p => p.id === patternId);
                    const percentage = Math.round((stats.correct / stats.total) * 100);
                    return (
                      <div key={patternId} className="flex items-center justify-between bg-white/10 rounded-lg p-3">
                        <span className="text-white font-medium">{pattern?.name || 'Unknown Pattern'}</span>
                        <div className="flex items-center space-x-3">
                          <div className="w-24 bg-white/20 rounded-full h-2">
                            <div 
                              className={`h-2 rounded-full ${
                                percentage >= 80 ? 'bg-green-400' :
                                percentage >= 60 ? 'bg-yellow-400' : 'bg-red-400'
                              }`}
                              style={{ width: `${percentage}%` }}
                            ></div>
                          </div>
                          <span className="text-white font-bold">{percentage}%</span>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>

              {/* Actions */}
              <div className="space-y-4">
                <button 
                  onClick={() => startTest(tier)} 
                  className="w-full bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-bold py-4 px-6 rounded-xl transition-all duration-300 hover:scale-105"
                >
                  다시 테스트! (Retake Test)
                </button>
                <div className="grid grid-cols-2 gap-4">
                  <button 
                    onClick={() => { setSelectedTier(tier); setScreen('pattern-selection'); }} 
                    className="bg-white/20 hover:bg-white/30 text-white font-bold py-3 px-6 rounded-xl transition-colors border border-white/30"
                  >
                    연습하기 (Practice)
                  </button>
                  <button 
                    onClick={() => setScreen('grammar-levels')} 
                    className="bg-white/10 hover:bg-white/20 text-white font-bold py-3 px-6 rounded-xl transition-colors border border-white/20"
                  >
                    홈으로 (Home)
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      }

      if (screen === 'pattern-selection') {
        const patterns = grammarPatterns[selectedTier];
        const backScreen = challengeMode ? 'challenge-selection' : 'grammar-levels';
        
        return (
          <div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 flex items-center justify-center p-4">
            <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full max-h-[90vh] overflow-y-auto">
              <button onClick={() => setScreen(backScreen)} className="flex items-center text-gray-600 hover:text-gray-800 mb-4 transition-colors">
                <ArrowLeft /><span className="ml-2">Back</span>
              </button>
              <h2 className="text-2xl font-bold text-gray-800 mb-6 text-center">
                {selectedTier === 'combo' ? 'Combo Patterns' : 'Select Pattern'}
              </h2>
              {challengeMode && (
                <div className="mb-4 p-3 bg-blue-100 rounded-lg">
                  <div className="text-blue-800 font-semibold">
                    {challengeMode === 'speed' && '⚡ Speed Round Active'}
                    {challengeMode === 'memory' && '🧠 Memory Challenge Active'}
                    {challengeMode === 'combo-challenge' && '✨ Combo Challenge Active'}
                  </div>
                </div>
              )}
              <div className="space-y-3">
                {patterns.map((pattern) => (
                  <button key={pattern.id} onClick={() => { setSelectedPattern(pattern); setScreen('difficulty-selection'); }} className="w-full bg-purple-100 hover:bg-purple-200 text-left p-4 rounded-xl transition-colors">
                    <div className="font-bold text-purple-900 text-lg">{pattern.name}</div>
                    <div className="text-purple-700 text-sm">{pattern.description}</div>
                    {selectedTier === 'combo' && (
                      <div className="text-xs text-purple-600 mt-1">🌟 Multiple patterns combined</div>
                    )}
                  </button>
                ))}
              </div>
            </div>
          </div>
        );
      }

      if (screen === 'difficulty-selection') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 flex items-center justify-center p-4">
            <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full">
              <button onClick={() => setScreen('pattern-selection')} className="flex items-center text-gray-600 hover:text-gray-800 mb-4 transition-colors">
                <ArrowLeft /><span className="ml-2">Back</span>
              </button>
              <div className="bg-purple-50 rounded-xl p-4 mb-6">
                <div className="font-bold text-purple-900 text-xl">{selectedPattern.name}</div>
                <div className="text-purple-700 text-sm">{selectedPattern.explanation}</div>
              </div>
              <h2 className="text-xl font-bold text-gray-800 mb-6 text-center">Sentence length:</h2>
              <div className="space-y-3">
                <button onClick={() => { setDifficulty('beginner'); setScreen('input-mode-selection'); }} className="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-4 rounded-xl transition-colors">Short</button>
                <button onClick={() => { setDifficulty('intermediate'); setScreen('input-mode-selection'); }} className="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-4 rounded-xl transition-colors">Medium</button>
                <button onClick={() => { setDifficulty('advanced'); setScreen('input-mode-selection'); }} className="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-4 rounded-xl transition-colors">Long</button>
              </div>
            </div>
          </div>
        );
      }

      if (screen === 'input-mode-selection') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 flex items-center justify-center p-4">
            <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full">
              <button onClick={() => setScreen('difficulty-selection')} className="flex items-center text-gray-600 hover:text-gray-800 mb-4 transition-colors">
                <ArrowLeft /><span className="ml-2">Back</span>
              </button>
              <h2 className="text-2xl font-bold text-gray-800 mb-6 text-center">Input mode:</h2>
              <div className="space-y-3">
                <button onClick={() => { setInputMode('tap'); setScreen('practice'); startNewSentenceSet(); }} className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-4 rounded-xl transition-colors">Tap Words</button>
                <button onClick={() => { setInputMode('type'); setScreen('practice'); startNewSentenceSet(); }} className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 rounded-xl transition-colors">Type Answer</button>
              </div>
            </div>
          </div>
        );
      }

      if (screen === 'practice' && currentSentenceSet) {
        const currentSentence = selectedPattern.tenseVariations ? currentSentenceSet[currentTense] : currentSentenceSet;

        return (
          <div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 flex items-center justify-center p-4">
            <div className="bg-white rounded-3xl shadow-2xl p-6 max-w-2xl w-full">
              <div className="flex justify-between items-center mb-4">
                <div>
                  <span className="text-sm font-bold text-gray-500">Score: {score}/{questionsAnswered}</span>
                  <div className="text-xs font-semibold text-purple-600 mt-1">
                    {selectedTier ? selectedPattern.name : `🎲 Random Mode - ${selectedPattern.name} (${selectedPattern.tier})`}
                  </div>
                </div>
                <button onClick={resetToStart} className="text-purple-600 hover:text-purple-800 font-semibold text-sm transition-colors">Exit</button>
              </div>

              {selectedPattern.tenseVariations && (
                <div className="flex gap-2 mb-6 justify-center">
                  <div className={`px-4 py-2 rounded-lg font-semibold text-sm ${currentTense === 'past' ? 'bg-blue-500 text-white' : tensesCompleted.includes('past') ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-500'}`}>
                    Past {tensesCompleted.includes('past') && '✓'}
                  </div>
                  <div className={`px-4 py-2 rounded-lg font-semibold text-sm ${currentTense === 'present' ? 'bg-purple-500 text-white' : tensesCompleted.includes('present') ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-500'}`}>
                    Present {tensesCompleted.includes('present') && '✓'}
                  </div>
                  <div className={`px-4 py-2 rounded-lg font-semibold text-sm ${currentTense === 'future' ? 'bg-orange-500 text-white' : tensesCompleted.includes('future') ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-500'}`}>
                    Future {tensesCompleted.includes('future') && '✓'}
                  </div>
                </div>
              )}

              <div className="mb-8">
                <div className="bg-purple-50 rounded-xl p-4 mb-6 text-center">
                  <p className="text-sm text-purple-700 mb-1">Build this sentence:</p>
                  <p className="text-xl font-bold text-purple-900">{currentSentence.meaning}</p>
                </div>

                {inputMode === 'tap' ? (
                  <>
                    <div className="bg-gray-50 rounded-xl p-6 mb-6 min-h-32 border-2 border-dashed border-gray-300">
                      <p className="text-xs text-gray-500 mb-3 text-center">Your sentence:</p>
                      {selectedParts.length === 0 ? (
                        <p className="text-center text-gray-400 text-sm">Tap words below</p>
                      ) : (
                        <div className="flex flex-wrap gap-2 justify-center">
                          {selectedParts.map((part, index) => (
                            <button key={index} onClick={() => handleRemovePart(index)} className="bg-purple-600 text-white px-4 py-3 rounded-lg font-bold text-lg hover:bg-purple-700 transition-colors">{part}</button>
                          ))}
                        </div>
                      )}
                    </div>
                    <div className="mb-6">
                      <p className="text-xs text-gray-500 mb-3 text-center">Available words:</p>
                      <div className="flex flex-wrap gap-2 justify-center">
                        {shuffledParts.map((part, index) => (
                          <button key={index} onClick={() => handlePartClick(part, index)} className="bg-white border-2 border-purple-300 text-purple-700 px-4 py-3 rounded-lg font-bold text-lg hover:bg-purple-50 transition-colors">{part}</button>
                        ))}
                      </div>
                    </div>
                  </>
                ) : (
                  <div className="mb-6">
                    <input type="text" value={typedAnswer} onChange={(e) => setTypedAnswer(e.target.value)} onKeyPress={(e) => { if (e.key === 'Enter' && !showFeedback && typedAnswer.trim()) checkAnswer(); }} placeholder="Type your answer..." disabled={showFeedback} className="w-full px-4 py-4 text-lg border-2 border-purple-300 rounded-xl focus:outline-none focus:border-purple-500 transition-colors" autoFocus />
                  </div>
                )}

                {showFeedback && (
                  <div className={`rounded-xl p-4 mb-6 ${isCorrect ? 'bg-green-50' : 'bg-red-50'}`}>
                    <div className="flex items-center justify-center mb-2">
                      {isCorrect ? (
                        <><div className="text-green-600 mr-2"><CheckCircle /></div><span className="text-green-800 font-bold">Perfect!</span></>
                      ) : (
                        <><div className="text-red-600 mr-2"><XCircle /></div><span className="text-red-800 font-bold">Not quite</span></>
                      )}
                    </div>
                    {!isCorrect && (
                      <div className="text-center">
                        <p className="text-red-700 text-sm">Correct:</p>
                        <p className="text-red-900 font-bold text-xl">{currentSentence.parts.join(' ')}</p>
                      </div>
                    )}
                  </div>
                )}

                <div className="flex flex-col gap-3">
                  {!showFeedback ? (
                    <>
                      <button onClick={checkAnswer} disabled={inputMode === 'tap' ? selectedParts.length !== currentSentence.parts.length : !typedAnswer.trim()} className={`w-full font-bold py-4 rounded-xl text-lg transition-colors ${(inputMode === 'tap' ? selectedParts.length === currentSentence.parts.length : typedAnswer.trim()) ? 'bg-purple-600 text-white hover:bg-purple-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}>Check</button>
                      <button onClick={() => { setIsCorrect(false); setShowFeedback(true); setQuestionsAnswered(questionsAnswered + 1); }} className="w-full bg-orange-500 text-white font-bold py-3 rounded-xl hover:bg-orange-600 transition-colors">Show Answer</button>
                    </>
                  ) : (
                    <button onClick={nextQuestion} className="w-full bg-purple-600 text-white font-bold py-4 rounded-xl flex items-center justify-center hover:bg-purple-700 transition-colors">
                      <span>{selectedPattern.tenseVariations && currentTense !== 'future' ? 'Next Tense' : 'New Sentence'}</span>
                      <div className="ml-2"><ArrowRight /></div>
                    </button>
                  )}
                </div>
              </div>
            </div>
          </div>
        );
      }

      console.log('Reached return null - this should not happen!');
      console.log('Current state:', { grammarPatterns: !!grammarPatterns, screen });
      return null;
    };

    console.log('About to render KoreanGrammarApp...');
    console.log('React version:', React.version);
    console.log('ReactDOM version:', ReactDOM.version);
    console.log('Root element:', document.getElementById('root'));
    
    try {
      ReactDOM.render(<KoreanGrammarApp />, document.getElementById('root'));
      console.log('KoreanGrammarApp rendered successfully!');
    } catch (error) {
      console.error('Error rendering KoreanGrammarApp:', error);
    }
  </script>
</body>
</html>